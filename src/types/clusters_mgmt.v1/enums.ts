/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/api/clusters_mgmt/v1': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the version metadata. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Metadata'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/addons': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of add-ons. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the add-on instead of
           *     the names of the columns of a table. For example, in order to sort the add-ons
           *     descending by name the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the add-on instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     add-ons with a name starting with `my` the value should be:
           *
           *     ```sql
           *     name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the add-ons
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of add-ons. */
              items?: components['schemas']['AddOn'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Create a new add-on and add it to the collection of add-ons. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddOn'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOn'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/addons/{addon_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the add-on. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addon_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOn'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the add-on. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addon_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the add-on. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addon_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddOn'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOn'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/addons/{addon_id}/versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of add-on versions. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the add-on instead of
           *     the names of the columns of a table. For example, in order to sort the add-on
           *     versions descending by id the value should be:
           *
           *     ```sql
           *     id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the add-on version instead
           *     of the names of the columns of a table. For example, in order to retrieve all the
           *     add-on versions with an id starting with `0.1` the value should be:
           *
           *     ```sql
           *     id like '0.1.%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the add-on
           *     versions that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          addon_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of add-on versions. */
              items?: components['schemas']['AddOnVersion'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Create a new add-on version and add it to the collection of add-ons. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addon_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddOnVersion'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOnVersion'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/addons/{addon_id}/versions/{version_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the add-on version. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addon_id: string;
          version_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOnVersion'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the add-on version. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addon_id: string;
          version_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the add-on version. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          addon_id: string;
          version_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddOnVersion'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOnVersion'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_infrastructure_access_roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the role instead of
           *     the names of the columns of a table. For example, in order to sort the roles
           *     descending by dislay_name the value should be:
           *
           *     ```sql
           *     display_name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the role instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     role with a name starting with `my`the value should be:
           *
           *     ```sql
           *     display_name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the roles
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of roles. */
              items?: components['schemas']['AWSInfrastructureAccessRole'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_infrastructure_access_roles/{aws_infrastructure_access_role_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the aws infrastructure access role. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          aws_infrastructure_access_role_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AWSInfrastructureAccessRole'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/machine_types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of machine types in the provided region. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of machine types. */
              items?: components['schemas']['MachineType'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/oidc_thumbprint': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Fetches/creates an OIDC Config Thumbprint from either a cluster ID, or an oidc config ID. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['OidcThumbprintInput'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['OidcThumbprint'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/regions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of available regions of the cloud provider.
     *     IMPORTANT: This list doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of available regions
     *     of the provider. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     regions of the provider. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of regions. */
              items?: components['schemas']['CloudRegion'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     regions of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of available regions of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/sts_account_roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     be the total number of STS account roles. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AWS'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description The AWS Account Id for the STS Account Roles */
              aws_account_id?: string;
              /** @description Retrieved list of STS Account Roles */
              items?: components['schemas']['AWSSTSAccountRole'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     be the total number of STS account roles.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of STS account roles
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/sts_credential_requests': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of policies. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of CredRequest. */
              items?: components['schemas']['STSCredentialRequest'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/sts_policies': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of policies. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the awsstspolicies instead of
           *     the names of the columns of a table. For example, in order to sort the policies
           *     descending by operator type identifier the value should be:
           *
           *     ```sql
           *     orderBy id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the awsstspolicies instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     policies of type  `operatorrole`
           *     should be:
           *
           *     ```sql
           *     policy_type like 'OperatorRole%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     policies  will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of policies. */
              items?: components['schemas']['AWSSTSPolicy'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/validate_credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Manages aws creds validation. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['CloudProviderData'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/aws_inquiries/vpcs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of available vpcs of the cloud provider for specific region.
     *     IMPORTANT: This collection doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of available vpcs
     *     of the provider. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     vpcs of the provider. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of cloud VPC. */
              items?: components['schemas']['CloudVPC'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     vpcs of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of available vpcs of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/cloud_providers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of cloud providers. */
    get: {
      parameters: {
        query?: {
          /** @description If true, includes the regions on each provider in the output. Could slow request response time. */
          fetchRegions?: boolean;
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the cloud provider
           *     instead of the names of the columns of a table. For example, in order to sort the
           *     clusters descending by name identifier the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the cloud provider
           *     instead of the names of the columns of a table. For example, in order to retrieve
           *     all the cloud providers with a name starting with `A` the value should be:
           *
           *     ```sql
           *     name like 'A%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the clusters
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of cloud providers. */
              items?: components['schemas']['CloudProvider'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the cloud provider. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cloud_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['CloudProvider'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/available_regions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of available regions of the cloud provider.
     *
     *     IMPORTANT: This collection doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of available regions
     *     of the provider. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     regions of the provider. */
          size?: number;
        };
        header?: never;
        path: {
          cloud_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AWS'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of cloud regions. */
              items?: components['schemas']['CloudRegion'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     regions of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of available regions of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of regions of the cloud provider.
     *
     *     IMPORTANT: This collection doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of regions
     *     of the provider. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     regions of the provider. */
          size?: number;
        };
        header?: never;
        path: {
          cloud_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of cloud providers. */
              items?: components['schemas']['CloudRegion'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     regions of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of regions of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a cloud region to the database. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cloud_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudRegion'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['CloudRegion'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/cloud_providers/{cloud_provider_id}/regions/{region_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the region. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cloud_provider_id: string;
          region_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['CloudRegion'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the region. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cloud_provider_id: string;
          region_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the region. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cloud_provider_id: string;
          region_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudRegion'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['CloudRegion'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of clusters. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the cluster instead of
           *     the names of the columns of a table. For example, in order to sort the clusters
           *     descending by region identifier the value should be:
           *
           *     ```sql
           *     region.id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the cluster instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     clusters with a name starting with `my` in the `us-east-1` region the value
           *     should be:
           *
           *     ```sql
           *     name like 'my%' and region.id = 'us-east-1'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     clusters that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of clusters. */
              items?: components['schemas']['Cluster'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Provision a new cluster and add it to the collection of clusters.
     *
     *     See the `register_cluster` method for adding an existing cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Cluster'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Cluster'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the cluster. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Cluster'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the cluster. */
    delete: {
      parameters: {
        query?: {
          /** @description BestEffort flag is used to check if the cluster deletion should be best-effort mode or not. */
          best_effort?: boolean;
          /** @description If false it will only delete from OCM but not the actual cluster resources.
           *     false is only allowed for OCP clusters. true by default. */
          deprovision?: boolean;
          /** @description Dry run flag is used to check if the operation can be completed, but won't delete. */
          dry_run?: boolean;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the cluster. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Cluster'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Cluster'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/hibernate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Initiates cluster hibernation. While hibernating a cluster will not consume any cloud provider infrastructure
     *     but will be counted for quota. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/resume': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Resumes from Hibernation. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_inquiries': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the add-on instead of
           *     the names of the columns of a table. For example, in order to sort the add-ons
           *     descending by name the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the add-on instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     add-ons with a name starting with `my` the value should be:
           *
           *     ```sql
           *     name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the add-ons
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of add-ons. */
              items?: components['schemas']['AddOn'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_inquiries/{addon_inquiry_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addon_inquiry_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOn'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of addon upgrade policies. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of addon upgrade policy. */
              items?: components['schemas']['AddonUpgradePolicy'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new addon upgrade policy to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddonUpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddonUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies/{addon_upgrade_policy_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the addon upgrade policy. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addon_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddonUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the addon upgrade policy. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addon_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update the addon upgrade policy. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addon_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddonUpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddonUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/addon_upgrade_policies/{addon_upgrade_policy_id}/state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the upgrade policy state. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addon_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddonUpgradePolicyState'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Update the upgrade policy state. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addon_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddonUpgradePolicyState'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddonUpgradePolicyState'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/addons': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of add-on installations. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the add-on installation
           *     instead of the names of the columns of a table. For example, in order to sort the
           *     add-on installations descending by name the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the add-on installation
           *     instead of the names of the columns of a table. For example, in order to retrieve
           *     all the add-on installations with a name starting with `my` the value should be:
           *
           *     ```sql
           *     name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the add-on
           *     installations that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of add-on installations. */
              items?: components['schemas']['AddOnInstallation'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Create a new add-on installation and add it to the collection of add-on installations on the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddOnInstallation'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOnInstallation'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/addons/{addoninstallation_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the add-on installation. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addoninstallation_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOnInstallation'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Delete an add-on installation and remove it from the collection of add-on installations on the cluster. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addoninstallation_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the add-on installation. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          addoninstallation_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AddOnInstallation'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AddOnInstallation'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/autoscaler': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the autoscaler of a cluster. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterAutoscaler'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Creates a new cluster autoscaler object. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ClusterAutoscaler'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterAutoscaler'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    /** @description Deletes the cluster autoscaler. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the cluster autoscaler. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ClusterAutoscaler'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterAutoscaler'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the configuration for the Private Link. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['PrivateLinkConfiguration'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration/principals': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of principals. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause
           *     of an SQL statement, but using the names of the attributes of the role binding
           *     instead of the names of the columns of a table. For example, in order to
           *     retrieve role bindings with role_id AuthenticatedUser:
           *
           *     ```sql
           *     role_id = 'AuthenticatedUser'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     items that the user has permission to see will be returned. */
          search?: string;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of principals. */
              items?: components['schemas']['PrivateLinkPrincipal'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new principal for the Private Link. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['PrivateLinkPrincipal'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['PrivateLinkPrincipal'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/private_link_configuration/principals/{principal_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the principal. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          principal_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['PrivateLinkPrincipal'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the principal. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          principal_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/aws/role_policy_bindings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description If true, retrieves role policy binding states from AWS. */
          fetchCurrent?: boolean;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of role policy bindings. */
              items?: components['schemas']['RolePolicyBinding'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of AWS infrastructure access role grants. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the AWS infrastructure access role grant
           *     instead of the names of the columns of a table. For example, in order to sort the
           *     AWS infrastructure access role grants descending by user ARN the value should be:
           *
           *     ```sql
           *     user_arn desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the AWS infrastructure access role grant
           *     instead of the names of the columns of a table. For example, in order to retrieve
           *     all the AWS infrastructure access role grants with a user ARN starting with `user` the value should be:
           *
           *     ```sql
           *     user_arn like '%user'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the AWS
           *     infrastructure access role grants that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of AWS infrastructure access role grants. */
              items?: components['schemas']['AWSInfrastructureAccessRoleGrant'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Create a new AWS infrastructure access role grant and add it to the collection of
     *     AWS infrastructure access role grants on the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['AWSInfrastructureAccessRoleGrant'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AWSInfrastructureAccessRoleGrant'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/aws_infrastructure_access_role_grants/{aws_infrastructure_access_role_grant_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the AWS infrastructure access role grant. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          aws_infrastructure_access_role_grant_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AWSInfrastructureAccessRoleGrant'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the AWS infrastructure access role grant. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          aws_infrastructure_access_role_grant_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/break_glass_credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of break glass credentials. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the break glass credentials
           *     instead of the the names of the columns of a table. For example, in order to sort the
           *     credentials descending by identifier the value should be:
           *
           *     ```sql
           *     id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the break glass credentials
           *     instead of the names of the columns of a table. For example, in order to retrieve all
           *     the credentials with a specific username and status the following is required:
           *
           *     ```sql
           *     username='user1' AND status='expired'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     break glass credentials that the user has permission to see will be returned. */
          search?: string;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of break glass credentials. */
              items?: components['schemas']['BreakGlassCredential'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new break glass credential to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['BreakGlassCredential'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['BreakGlassCredential'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    /** @description Revokes all the break glass certificates signed by a specific signer. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/break_glass_credentials/{break_glass_credential_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the break glass credential. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          break_glass_credential_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['BreakGlassCredential'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/clusterdeployment': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** @description Deletes the clusterdeployment. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the control plane */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ControlPlane'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Updates the control plane */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ControlPlane'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ControlPlane'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane/upgrade_policies': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of upgrade policies for the control plane. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of upgrade policy. */
              items?: components['schemas']['ControlPlaneUpgradePolicy'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new upgrade policy to the control plane of the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ControlPlaneUpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ControlPlaneUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/control_plane/upgrade_policies/{control_plane_upgrade_policy_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the upgrade policy for the control plane. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          control_plane_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ControlPlaneUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the upgrade policy for the control plane. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          control_plane_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update the upgrade policy for the control plane. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          control_plane_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ControlPlaneUpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ControlPlaneUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the credentials of a cluster. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterCredentials'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/delete_protection': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['DeleteProtection'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['DeleteProtection'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['DeleteProtection'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_auth_config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ExternalAuthConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_auth_config/external_auths': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of external authentications. */
              items?: components['schemas']['ExternalAuth'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new authentication to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ExternalAuth'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ExternalAuth'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_auth_config/external_auths/{external_auth_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of an external authentication. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          external_auth_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ExternalAuth'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the external authentication. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          external_auth_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the external authentication. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          external_auth_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ExternalAuth'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ExternalAuth'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the external configuration. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ExternalConfiguration'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of labels. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of labels. */
              items?: components['schemas']['Label'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new label to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Label'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Label'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/labels/{label_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the label. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          label_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Label'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the label. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          label_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update the label. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          label_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Label'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Label'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/manifests': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of manifests. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of Manifests. */
              items?: components['schemas']['Manifest'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new manifest to a cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Manifest'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Manifest'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/manifests/{manifest_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the manifest. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          manifest_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Manifest'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the manifest. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          manifest_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update the manifest. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          manifest_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Manifest'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Manifest'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of syncsets. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of syncsets. */
              items?: components['schemas']['Syncset'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new syncset to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Syncset'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Syncset'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/external_configuration/syncsets/{syncset_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the syncset. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          syncset_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Syncset'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the syncset. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          syncset_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update the syncset. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          syncset_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Syncset'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Syncset'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of reasons. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of version gate agreement. */
              items?: components['schemas']['VersionGateAgreement'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new agreed version gate to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['VersionGateAgreement'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['VersionGateAgreement'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/gate_agreements/{version_gate_agreement_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the version gate agreement. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          version_gate_agreement_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['VersionGateAgreement'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the version gate agreement. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          version_gate_agreement_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of groups. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of groups. */
              items?: components['schemas']['Group'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the group. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          group_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Group'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of users. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
          group_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of users. */
              items?: components['schemas']['User'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new user to the group. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          group_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['User'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['User'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/groups/{group_id}/users/{user_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the user. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          group_id: string;
          user_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['User'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the user. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          group_id: string;
          user_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/hypershift': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the Hypershift details for a single cluster. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['HypershiftConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Updates the Hypershift details for a single cluster. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['HypershiftConfig'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['HypershiftConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of identity providers. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of identity providers. */
              items?: components['schemas']['IdentityProvider'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new identity provider to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['IdentityProvider'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['IdentityProvider'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the identity provider. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['IdentityProvider'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the identity provider. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update identity provider in the cluster. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['IdentityProvider'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['IdentityProvider'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of _HTPasswd_ IDP users. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of users of the IDP. */
              items?: components['schemas']['HTPasswdUser'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new user to the _HTPasswd_ file. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['HTPasswdUser'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['HTPasswdUser'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/import': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Adds multiple new users to the _HTPasswd_ file. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': {
            /** @description List of users to add to the IDP. */
            items?: components['schemas']['HTPasswdUser'][];
            /**
             * Format: int32
             * @description Index of the requested page, where one corresponds to the first page.
             */
            page?: number;
            /**
             * Format: int32
             * @description Number of items contained in the returned page.
             */
            size?: number;
          };
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Updated list of users of the IDP. */
              items?: components['schemas']['HTPasswdUser'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/identity_providers/{identity_provider_id}/htpasswd_users/{htpasswd_user_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the user. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
          htpasswd_user_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['HTPasswdUser'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the user. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
          htpasswd_user_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the user's password. The username is not editable */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          identity_provider_id: string;
          htpasswd_user_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['HTPasswdUser'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['HTPasswdUser'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/image_mirrors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of image mirrors for the cluster. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria for sorting results. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria for filtering results.
           *     Searchable fields: id, name, cluster_id, source, type
           *     All searchable fields can be ordered with asc/desc direction, default order by id */
          search?: string;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of image mirrors. */
              items?: components['schemas']['ImageMirror'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Creates a new image mirror configuration for the cluster.
     *     Cluster must be in ready state for this operation to succeed. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ImageMirror'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ImageMirror'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/image_mirrors/{image_mirror_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the image mirror. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          image_mirror_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ImageMirror'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the image mirror configuration. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          image_mirror_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the image mirror configuration.
     *     Note: Id and Source fields are immutable and cannot be updated.
     *     The mirrors array is completely replaced, not merged. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          image_mirror_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ImageMirror'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ImageMirror'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/inflight_checks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of inflight checks. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of inflight checks. */
              items?: components['schemas']['InflightCheck'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/inflight_checks/{inflight_check_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the inflight check. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          inflight_check_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['InflightCheck'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of ingresses. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of ingresses. */
              items?: components['schemas']['Ingress'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new ingress to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Ingress'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Ingress'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    /** @description Updates all ingresses */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Ingress'][];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Ingress'][];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/ingresses/{ingress_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the ingress. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          ingress_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Ingress'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the ingress. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          ingress_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the ingress. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          ingress_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Ingress'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Ingress'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/kubelet_config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the KubeletConfig for a cluster */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['KubeletConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Creates a new cluster KubeletConfig */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['KubeletConfig'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['KubeletConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    /** @description Deletes the cluster KubeletConfig */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the existing cluster KubeletConfig */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['KubeletConfig'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['KubeletConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/kubelet_configs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of KubeletConfigs for the cluster. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of KubeletConfigs. */
              items?: components['schemas']['KubeletConfig'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new KubeletConfig to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['KubeletConfig'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['KubeletConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/kubelet_configs/{kubelet_config_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the KubeletConfig specified by the id. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          kubelet_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['KubeletConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the KubeletConfig specified by the id. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          kubelet_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the KubeletConfig specified by the id. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          kubelet_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['KubeletConfig'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['KubeletConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of reasons. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of template. */
              items?: components['schemas']['LimitedSupportReason'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new reason to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['LimitedSupportReason'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['LimitedSupportReason'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/limited_support_reasons/{limited_support_reason_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the reason. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          limited_support_reason_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['LimitedSupportReason'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the reason. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          limited_support_reason_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of log links. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of log links. */
              items?: components['schemas']['Log'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/install': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the log. */
    get: {
      parameters: {
        query?: {
          /** @description Line offset to start logs from. if 0 retreive entire log.
           *     If offset > #lines return an empty log. */
          offset?: number;
          /** @description Returns the number of tail lines from the end of the log.
           *     If there are no line breaks or the number of lines < tail
           *     return the entire log.
           *     Either 'tail' or 'offset' can be set. Not both.  */
          tail?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Log'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/logs/uninstall': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the log. */
    get: {
      parameters: {
        query?: {
          /** @description Line offset to start logs from. if 0 retreive entire log.
           *     If offset > #lines return an empty log. */
          offset?: number;
          /** @description Returns the number of tail lines from the end of the log.
           *     If there are no line breaks or the number of lines < tail
           *     return the entire log.
           *     Either 'tail' or 'offset' can be set. Not both.  */
          tail?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Log'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of machine pools. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of machine pools. */
              items?: components['schemas']['MachinePool'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new machine pool to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['MachinePool'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['MachinePool'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/machine_pools/{machine_pool_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the machine pool. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          machine_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['MachinePool'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the machine pool. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          machine_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the machine pool. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          machine_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['MachinePool'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['MachinePool'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/alerts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AlertsInfo'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cluster_operators': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterOperatorsInfo'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/cpu_total_by_node_roles_os': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the metrics. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['CPUTotalsNodeRoleOSMetricNode'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/nodes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NodesInfo'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/metric_queries/socket_total_by_node_roles_os': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the metrics. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['SocketTotalsNodeRoleOSMetricNode'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/migrations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of cluster migrations. */
              items?: components['schemas']['ClusterMigration'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of migrations of the cluster.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a cluster migration to the database. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ClusterMigration'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterMigration'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/migrations/{migration_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the cluster migration. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          migration_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterMigration'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of node pools. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the node pools instead of
           *     the names of the columns of a table. For example, in order to sort the node pools
           *     descending by identifier the value should be:
           *
           *     ```sql
           *     id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the node pools instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     node pools with replicas of two the following is required:
           *
           *     ```sql
           *     replicas = 2
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     node pools that the user has permission to see will be returned. */
          search?: string;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of node pools. */
              items?: components['schemas']['NodePool'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new node pool to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['NodePool'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NodePool'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the node pool. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NodePool'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the node pool. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the node pool. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['NodePool'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NodePool'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}/upgrade_policies': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of upgrade policies for the node pool. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of upgrade policy. */
              items?: components['schemas']['NodePoolUpgradePolicy'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new upgrade policy to the node pool of the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['NodePoolUpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NodePoolUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/node_pools/{node_pool_id}/upgrade_policies/{node_pool_upgrade_policy_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the upgrade policy for the node pool. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
          node_pool_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NodePoolUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the upgrade policy for the node pool. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
          node_pool_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update the upgrade policy for the node pool. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          node_pool_id: string;
          node_pool_upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['NodePoolUpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NodePoolUpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/provision_shard': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the provision shard. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ProvisionShard'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Delete the provision shard. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the details of the provision shard. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ProvisionShard'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ProvisionShard'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/resources': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves a list of resources for a cluster in error state */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterResources'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/resources/live': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves currently available cluster resources */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterResources'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ClusterStatus'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of operator roles. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of operator roles. */
              items?: components['schemas']['OperatorIAMRole'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new operator role to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['OperatorIAMRole'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['OperatorIAMRole'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_operator_roles/{operator_iam_role_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** @description Deletes the operator role. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          operator_iam_role_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/sts_support_jump_role': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['StsSupportJumpRole'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/tuning_configs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of tuning configs. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of tuning configs. */
              items?: components['schemas']['TuningConfig'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new tuning config to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['TuningConfig'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['TuningConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/tuning_configs/{tuning_config_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the tuning config. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          tuning_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['TuningConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the tuning config. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          tuning_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the tuning config. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          tuning_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['TuningConfig'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['TuningConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of upgrade policies. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of upgrade policy. */
              items?: components['schemas']['UpgradePolicy'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new upgrade policy to the cluster. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['UpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['UpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the upgrade policy. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['UpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the upgrade policy. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Update the upgrade policy. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['UpgradePolicy'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['UpgradePolicy'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/upgrade_policies/{upgrade_policy_id}/state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the upgrade policy state. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['UpgradePolicyState'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Update the upgrade policy state. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
          upgrade_policy_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['UpgradePolicyState'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['UpgradePolicyState'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/clusters/{cluster_id}/vpc': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['CloudVPC'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/dns_domains': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the dns domain instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     dns domains with a ID starting with `02a5` should be:
           *
           *     ```sql
           *     id like '02a5%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     dns domains that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved a list of DNS domains. */
              items?: components['schemas']['DNSDomain'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a DNS domain. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['DNSDomain'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['DNSDomain'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/dns_domains/{dns_domain_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the DNS domain. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          dns_domain_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['DNSDomain'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Delete the DNS domain. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          dns_domain_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/environment': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the environment. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Environment'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Updates the environment.
     *
     *     Attributes that can be updated are:
     *
     *     - `last_upgrade_available_check`
     *     - `last_limited_support_check` */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Environment'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Environment'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Adds a new event to be tracked. When sending a new event request,
     *     it gets tracked in Prometheus, Pendo, CloudWatch, or whichever
     *     analytics client is configured as part of clusters service. This
     *     allows for reporting on events that happen outside of a regular API
     *     request, but are found to be useful for understanding customer
     *     needs and possible blockers. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Event'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Event'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/flavours': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the flavour instead of
           *     the names of the columns of a table. For example, in order to sort the flavours
           *     descending by name the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the flavour instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     flavours with a name starting with `my`the value should be:
           *
           *     ```sql
           *     name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the flavours
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of flavours. */
              items?: components['schemas']['Flavour'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/flavours/{flavour_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the cluster flavour. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          flavour_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Flavour'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Updates the flavour.
     *
     *     Attributes that can be updated are:
     *
     *     - `aws.infra_volume`
     *     - `aws.infra_instance_type`
     *     - `gcp.infra_instance_type` */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          flavour_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['Flavour'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Flavour'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp/wif_configs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of wif_configs */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the cluster instead of
           *     the names of the columns of a table. For example, in order to sort the clusters
           *     descending by region identifier the value should be:
           *
           *     ```sql
           *     region.id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the cluster instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     clusters with a name starting with `my` in the `us-east-1` region the value
           *     should be:
           *
           *     ```sql
           *     name like 'my%' and region.id = 'us-east-1'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     wif_configs that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of wif_configs. */
              items?: components['schemas']['WifConfig'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Provision a new wif_config resource and add it to the collection of wif_configs. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['WifConfig'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['WifConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp/wif_configs/{wif_config_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the WifConfig. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          wif_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['WifConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the wif_config. */
    delete: {
      parameters: {
        query?: {
          /** @description Dry run flag is used to check if the operation can be completed, but won't delete. */
          dry_run?: boolean;
        };
        header?: never;
        path: {
          wif_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the WifConfig. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          wif_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['WifConfig'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['WifConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp/wif_configs/{wif_config_id}/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          wif_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['WifConfigStatus'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp_inquiries/encryption_keys': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of encryption keys.
     *     IMPORTANT: This collection doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of available regions
     *     of the provider. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     regions of the provider. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of encryption keys. */
              items?: components['schemas']['EncryptionKey'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     regions of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of available regions of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp_inquiries/key_rings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of available key rings of the cloud provider.
     *     IMPORTANT: This collection doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of available regions
     *     of the provider. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     key rings of the provider. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of key rings. */
              items?: components['schemas']['KeyRing'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     key rings of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of available key rings of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp_inquiries/machine_types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of machine types in the provided region. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of machine types. */
              items?: components['schemas']['MachineType'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp_inquiries/regions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of available regions of the cloud provider.
     *     IMPORTANT: This list doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of available regions
     *     of the provider. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     regions of the provider. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of regions. */
              items?: components['schemas']['CloudRegion'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     regions of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of available regions of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/gcp_inquiries/vpcs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Retrieves the list of available vpcs of the cloud provider for specific region.
     *     IMPORTANT: This collection doesn't currently support paging or searching, so the returned
     *     `page` will always be 1 and `size` and `total` will always be the total number of available vpcs
     *     of the provider. */
    post: {
      parameters: {
        query?: {
          /** @description Index of the returned page, where one corresponds to the first page. As this
           *     collection doesn't support paging the result will always be `1`. */
          page?: number;
          /** @description Number of items that will be contained in the returned page. As this collection
           *     doesn't support paging or searching the result will always be the total number of
           *     vpcs of the provider. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['CloudProviderData'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of cloud VPC. */
              items?: components['schemas']['CloudVPC'][];
              /**
               * Format: int32
               * @description Index of the returned page, where one corresponds to the first page. As this
               *     collection doesn't support paging the result will always be `1`.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items that will be contained in the returned page. As this collection
               *     doesn't support paging or searching the result will always be the total number of
               *     vpcs of the provider.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page. As this collection doesn't support paging or
               *     searching the result will always be the total number of available vpcs of the provider.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/limited_support_reason_templates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of templates. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of template. */
              items?: components['schemas']['LimitedSupportReasonTemplate'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/limited_support_reason_templates/{limited_support_reason_template_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the template. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          limited_support_reason_template_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['LimitedSupportReasonTemplate'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/load_balancer_quota_values': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of Load Balancer Quota Values. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of values. */
              items?: number[];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/machine_types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of machine types. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the machine type
           *     instead of the names of the columns of a table. For example, in order to sort the
           *     machine types descending by name identifier the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the machine type
           *     instead of the names of the columns of a table. For example, in order to retrieve
           *     all the machine types with a name starting with `A` the value should be:
           *
           *     ```sql
           *     name like 'A%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the machine
           *     types that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of cloud providers. */
              items?: components['schemas']['MachineType'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/machine_types/{machine_type_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the machine type. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          machine_type_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['MachineType'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/network_verifications': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** @description Creates an entry for a network verification for each subnet supplied setting then to initial state. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['NetworkVerification'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['NetworkVerification'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/network_verifications/{network_verification_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of a subnet network verification. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          network_verification_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['SubnetNetworkVerification'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/oidc_configs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of oidc configs. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of identity providers. */
              items?: components['schemas']['OidcConfig'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Creates a hosting under Red Hat's S3 bucket for byo oidc configuration. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['OidcConfig'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['OidcConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/oidc_configs/{oidc_config_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of an OidcConfig. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          oidc_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['OidcConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the OidcConfig. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          oidc_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates attributes of an OidcConfig. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          oidc_config_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['OidcConfig'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['OidcConfig'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/pending_delete_clusters': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of pending delete clusters. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the pending delete cluster instead of
           *     the names of the columns of a table. For example, in order to sort the pending delete clusters
           *     descending by creation timestamp (i.e. their deletion time) the value should be:
           *
           *     ```sql
           *     creation_timestamp desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the pending delete cluster instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     pending delete clusters with creation time later than 2023-03-01T00:00:00Z the following is required:
           *
           *     ```sql
           *     creation_timestamp > '2023-03-01T00:00:00Z'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     pending delete clusters that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of pending delete clusters. */
              items?: components['schemas']['PendingDeleteCluster'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/pending_delete_clusters/{pending_delete_cluster_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the pending delete cluster. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          pending_delete_cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['PendingDeleteCluster'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** @description Updates the pending delete cluster entry. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          pending_delete_cluster_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['PendingDeleteCluster'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['PendingDeleteCluster'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/products': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of products. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the product instead of
           *     the names of the columns of a table. For example, in order to sort the products
           *     descending by name the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the product instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     products with a name starting with `my` the value should be:
           *
           *     ```sql
           *     name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the products
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of products. */
              items?: components['schemas']['Product'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/products/{product_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the product. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          product_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Product'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/products/{product_id}/minimal_versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of product minimal versions. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the product instead of
           *     the names of the columns of a table. For example, in order to sort the products
           *     descending by name the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the product instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     products with a name starting with `my` the value should be:
           *
           *     ```sql
           *     name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the products
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          product_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of product minimal versions. */
              items?: components['schemas']['ProductMinimalVersion'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/products/{product_id}/minimal_versions/{minimal_version_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the product minimal version. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          product_id: string;
          minimal_version_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ProductMinimalVersion'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/products/{product_id}/technology_previews': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of product technology previews. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the product instead of
           *     the names of the columns of a table. For example, in order to sort the products
           *     descending by name the value should be:
           *
           *     ```sql
           *     name desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the product instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     products with a name starting with `my` the value should be:
           *
           *     ```sql
           *     name like 'my%'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the products
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path: {
          product_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of product technology previews. */
              items?: components['schemas']['ProductTechnologyPreview'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/products/{product_id}/technology_previews/{technology_preview_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the product technology preview. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          product_id: string;
          technology_preview_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ProductTechnologyPreview'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/provision_shards': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the cluster instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     clusters with a name starting with `my` in the `us-east-1` region the value
           *     should be:
           *
           *     ```sql
           *     name like 'my%' and region.id = 'us-east-1'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     provision shards that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved a list of provision shards. */
              items?: components['schemas']['ProvisionShard'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a provision shard. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ProvisionShard'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ProvisionShard'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/provision_shards/{provision_shard_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the provision shard. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          provision_shard_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ProvisionShard'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Delete the provision shard. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          provision_shard_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    /** @description Updates the details of the provision shard. */
    patch: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          provision_shard_id: string;
        };
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['ProvisionShard'];
        };
      };
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['ProvisionShard'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    trace?: never;
  };
  '/api/clusters_mgmt/v1/registry_allowlists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of registry allowlists. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the registry allowlists
           *     instead of the the names of the columns of a table. For example, in order to sort the
           *     allowlists descending by identifier the value should be:
           *
           *     ```sql
           *     creation_timestamp desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the registry allowlists
           *     instead of the names of the columns of a table. For example, in order to retrieve all
           *     the allowlists with a specific cloud provider and creation time the following is required:
           *
           *     ```sql
           *     cloud_provider.id='aws' and creation_timestamp > '2023-03-01T00:00:00Z'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the
           *     registry allowlists that the user has permission to see will be returned. */
          search?: string;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of registry allowlists. */
              items?: components['schemas']['RegistryAllowlist'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new break registry allowlist. */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['RegistryAllowlist'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['RegistryAllowlist'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/registry_allowlists/{registry_allowlist_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the allowlist. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          registry_allowlist_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['RegistryAllowlist'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the allowlist. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          registry_allowlist_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/storage_quota_values': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of Storage Quota Values. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of values. */
              items?: components['schemas']['StorageQuota'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/trusted_ip_addresses': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the list of trusted ip addresses. */
    get: {
      parameters: {
        query?: {
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Number of items contained in the returned page. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of trusted ip addresses. */
              items?: components['schemas']['TrustedIp'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Number of items contained in the returned page.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/version_gates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves a list of version gates. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     an SQL statement, but using the names of the attributes of the version gate instead of
           *     the names of the columns of a table. For example, in order to sort the version gates
           *     descending by identifier the value should be:
           *
           *     ```sql
           *     id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of an
           *     SQL statement, but using the names of the attributes of the version gate instead of
           *     the names of the columns of a table.
           *
           *     If the parameter isn't provided, or if the value is empty, then all the version gates
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page.
           *
           *     Default value is `100`. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of version gates. */
              items?: components['schemas']['VersionGate'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               *
               *     Default value is `100`.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    /** @description Adds a new version gate */
    post: {
      parameters: {
        query?: never;
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: {
        content: {
          'application/json': components['schemas']['VersionGate'];
        };
      };
      responses: {
        /** @description Success. */
        201: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['VersionGate'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/version_gates/{version_gate_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the version gate. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          version_gate_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['VersionGate'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    /** @description Deletes the version gate. */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          version_gate_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        204: {
          headers: {
            [name: string]: unknown;
          };
          content?: never;
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves a list of versions. */
    get: {
      parameters: {
        query?: {
          /** @description Order criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _order by_ clause of
           *     a SQL statement, but using the names of the attributes of the version instead of
           *     the names of the columns of a table. For example, in order to sort the versions
           *     descending by identifier the value should be:
           *
           *     ```sql
           *     id desc
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then the order of the
           *     results is undefined. */
          order?: string;
          /** @description Index of the requested page, where one corresponds to the first page. */
          page?: number;
          /** @description Search criteria.
           *
           *     The syntax of this parameter is similar to the syntax of the _where_ clause of a
           *     SQL statement, but using the names of the attributes of the version instead of
           *     the names of the columns of a table. For example, in order to retrieve all the
           *     versions that are enabled:
           *
           *     ```sql
           *     enabled = 't'
           *     ```
           *
           *     If the parameter isn't provided, or if the value is empty, then all the versions
           *     that the user has permission to see will be returned. */
          search?: string;
          /** @description Maximum number of items that will be contained in the returned page.
           *
           *     Default value is `100`. */
          size?: number;
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': {
              /** @description Retrieved list of versions. */
              items?: components['schemas']['Version'][];
              /**
               * Format: int32
               * @description Index of the requested page, where one corresponds to the first page.
               */
              page?: number;
              /**
               * Format: int32
               * @description Maximum number of items that will be contained in the returned page.
               *
               *     Default value is `100`.
               */
              size?: number;
              /**
               * Format: int32
               * @description Total number of items of the collection that match the search criteria,
               *     regardless of the size of the page.
               */
              total?: number;
            };
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/api/clusters_mgmt/v1/versions/{version_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Retrieves the details of the version. */
    get: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          version_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Success. */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Version'];
          };
        };
        /** @description Error. */
        default: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['Error'];
          };
        };
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Version metadata. */
    Metadata: {
      /** @description Version of the server. */
      server_version?: string;
    };
    /** @description AMIOverride specifies what Amazon Machine Image should be used for a particular product and region. */
    AMIOverride: {
      /** @description Indicates the type of this object. Will be 'AMIOverride' if this is a complete object or 'AMIOverrideLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description AMI is the id of the Amazon Machine Image. */
      ami?: string;
      /** @description Link to the product type. */
      product?: components['schemas']['Product'];
      /** @description Link to the cloud provider region. */
      region?: components['schemas']['CloudRegion'];
    };
    /** @description _Amazon Web Services_ specific settings of a cluster. */
    AWS: {
      /** @description Customer Managed Key to encrypt EBS Volume */
      kms_key_arn?: string;
      /** @description Contains the necessary attributes to support role-based authentication on AWS. */
      sts?: components['schemas']['STS'];
      /** @description AWS access key identifier. */
      access_key_id?: string;
      /** @description AWS account identifier. */
      account_id?: string;
      /** @description Additional allowed principal ARNs to be added to the hosted control plane's VPC Endpoint Service. */
      additional_allowed_principals?: string[];
      /** @description Additional AWS Security Groups to be added to default worker (compute) machine pool. */
      additional_compute_security_group_ids?: string[];
      /** @description Additional AWS Security Groups to be added to default control plane machine pool. */
      additional_control_plane_security_group_ids?: string[];
      /** @description Additional AWS Security Groups to be added to default infra machine pool. */
      additional_infra_security_group_ids?: string[];
      /** @description Audit log forwarding configuration */
      audit_log?: components['schemas']['AuditLog'];
      /** @description AWS specific configuration for AutoNode */
      auto_node?: components['schemas']['AwsAutoNode'];
      /** @description BillingAccountID is the account used for billing subscriptions purchased via the marketplace */
      billing_account_id?: string;
      /** @description Which Ec2MetadataHttpTokens to use for metadata service interaction options for EC2 instances */
      ec2_metadata_http_tokens?: components['schemas']['Ec2MetadataHttpTokens'];
      /** @description Related etcd encryption configuration */
      etcd_encryption?: components['schemas']['AwsEtcdEncryption'];
      /** @description ID of local private hosted zone for hypershift internal communication. */
      hcp_internal_communication_hosted_zone_id?: string;
      /** @description ID of private hosted zone. */
      private_hosted_zone_id?: string;
      /** @description Role ARN for private hosted zone. */
      private_hosted_zone_role_arn?: string;
      /** @description Sets cluster to be inaccessible externally. */
      private_link?: boolean;
      /** @description Manages additional configuration for Private Links. */
      private_link_configuration?: components['schemas']['PrivateLinkClusterConfiguration'];
      /** @description AWS secret access key. */
      secret_access_key?: string;
      /** @description The subnet ids to be used when installing the cluster. */
      subnet_ids?: string[];
      /** @description Optional keys and values that the installer will add as tags to all AWS resources it creates */
      tags?: {
        [key: string]: string;
      };
      /** @description Role ARN for VPC Endpoint Service cross account role. */
      vpc_endpoint_role_arn?: string;
    };
    /** @description Backup configuration for AWS clusters */
    AWSBackupConfig: {
      /** @description Name of the S3 bucket used to save the backup */
      s3_bucket?: string;
      /** @description ID of the AWS Disaster Recovery (DR) account */
      account_id?: string;
      /** @description ARN of the identity provider created in the Disaster Recovery (DR) account for the Management Cluster */
      identity_provider_arn?: string;
      /** @description Name of the management cluster the backup config refers to */
      management_cluster?: string;
      /** @description ARN of the role used by the CS Trusted Account to gain access to the Disaster Recovery (DR) account */
      role_arn?: string;
    };
    /** @description AWS Capacity Reservation specification. */
    AWSCapacityReservation: {
      /** @description Specify the target Capacity Reservation in which the EC2 instances will be launched. */
      id?: string;
      /** @description marketType specifies the market type of the CapacityReservation for the EC2
       *     instances. Valid values are OnDemand, CapacityBlocks.
       *     "OnDemand": EC2 instances run as standard On-Demand instances.
       *     "CapacityBlocks": scheduled pre-purchased compute capacity. */
      market_type?: components['schemas']['MarketType'];
    };
    /** @description Specification for different classes of nodes inside a flavour. */
    AWSFlavour: {
      /** @description AWS default instance type for the worker volume.
       *
       *     User can be overridden specifying in the cluster itself a type for compute node. */
      compute_instance_type?: string;
      /** @description AWS default instance type for the infra volume. */
      infra_instance_type?: string;
      /** @description Infra volume specification. */
      infra_volume?: components['schemas']['AWSVolume'];
      /** @description AWS default instance type for the master volume. */
      master_instance_type?: string;
      /** @description Master volume specification. */
      master_volume?: components['schemas']['AWSVolume'];
      /** @description Worker volume specification. */
      worker_volume?: components['schemas']['AWSVolume'];
    };
    /** @description A set of acces permissions for AWS resources */
    AWSInfrastructureAccessRole: {
      /** @description Indicates the type of this object. Will be 'AWSInfrastructureAccessRole' if this is a complete object or 'AWSInfrastructureAccessRoleLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Description of the role. */
      description?: string;
      /** @description Human friendly identifier of the role, for example `Read only`. */
      display_name?: string;
      /** @description State of the role. */
      state?: components['schemas']['AWSInfrastructureAccessRoleState'];
    };
    /** @description Representation of an AWS infrastructure access role grant. */
    AWSInfrastructureAccessRoleGrant: {
      /** @description Indicates the type of this object. Will be 'AWSInfrastructureAccessRoleGrant' if this is a complete object or 'AWSInfrastructureAccessRoleGrantLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description URL to switch to the role in AWS console. */
      console_url?: string;
      /** @description Link to AWS infrastructure access role.
       *     Grant must use a 'valid' role.  */
      role?: components['schemas']['AWSInfrastructureAccessRole'];
      /** @description State of the grant. */
      state?: components['schemas']['AWSInfrastructureAccessRoleGrantState'];
      /** @description Description of the state.
       *     Will be empty unless state is 'Failed'. */
      state_description?: string;
      /** @description The user AWS IAM ARN we want to grant the role. */
      user_arn?: string;
    };
    /**
     * @description State of an AWS infrastructure access role grant.
     * @enum {string}
     */
    AWSInfrastructureAccessRoleGrantState: AWSInfrastructureAccessRoleGrantState;
    /**
     * @description State of an AWS infrastructure access role.
     * @enum {string}
     */
    AWSInfrastructureAccessRoleState: AWSInfrastructureAccessRoleState;
    /** @description Representation of aws machine pool specific parameters. */
    AWSMachinePool: {
      /** @description Indicates the type of this object. Will be 'AWSMachinePool' if this is a complete object or 'AWSMachinePoolLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Additional AWS Security Groups to be added machine pool. Note that machine pools can only be worker node at the time. */
      additional_security_group_ids?: string[];
      /** @description Associates nodepool availability zones with zone types (e.g. wavelength, local). */
      availability_zone_types?: {
        [key: string]: string;
      };
      /** @description Use spot instances on this machine pool to reduce cost. */
      spot_market_options?: components['schemas']['AWSSpotMarketOptions'];
      /** @description Associates nodepool subnets with AWS Outposts. */
      subnet_outposts?: {
        [key: string]: string;
      };
      /** @description Optional keys and values that the machine pool provisioner will add as AWS tags to all AWS resources it creates.
       *
       *     AWS tags must conform to the following standards:
       *     - Each resource may have a maximum of 25 tags
       *     - Tags beginning with "aws:" are reserved for system use and may not be set
       *     - Tag keys may be between 1 and 128 characters in length
       *     - Tag values may be between 0 and 256 characters in length
       *     - Tags may only contain letters, numbers, spaces, and the following characters: [_ . : / = + - @] */
      tags?: {
        [key: string]: string;
      };
    };
    /** @description Representation of aws node pool specific parameters. */
    AWSNodePool: {
      /** @description Indicates the type of this object. Will be 'AWSNodePool' if this is a complete object or 'AWSNodePoolLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Additional AWS Security Groups to be added node pool. */
      additional_security_group_ids?: string[];
      /** @description Associates nodepool availability zones with zone types (e.g. wavelength, local). */
      availability_zone_types?: {
        [key: string]: string;
      };
      /** @description If present it defines the AWS Capacity Reservation used for this NodePool */
      capacity_reservation?: components['schemas']['AWSCapacityReservation'];
      /** @description Which Ec2MetadataHttpTokens to use for metadata service interaction options for EC2 instances */
      ec2_metadata_http_tokens?: components['schemas']['Ec2MetadataHttpTokens'];
      /** @description InstanceProfile is the AWS EC2 instance profile, which is a container for an IAM role that the EC2 instance uses. */
      instance_profile?: string;
      /** @description InstanceType is an ec2 instance type for node instances (e.g. m5.large). */
      instance_type?: string;
      /** @description AWS Volume specification to be used to set custom worker disk size */
      root_volume?: components['schemas']['AWSVolume'];
      /** @description Associates nodepool subnets with AWS Outposts. */
      subnet_outposts?: {
        [key: string]: string;
      };
      /** @description Optional keys and values that the installer will add as tags to all AWS resources it creates.
       *
       *     AWS tags must conform to the following standards:
       *     - Each resource may have a maximum of 25 tags
       *     - Tags beginning with "aws:" are reserved for system use and may not be set
       *     - Tag keys may be between 1 and 128 characters in length
       *     - Tag values may be between 0 and 256 characters in length
       *     - Tags may only contain letters, numbers, spaces, and the following characters: [_ . : / = + - @] */
      tags?: {
        [key: string]: string;
      };
    };
    /** @description Config for AWS provision shards */
    AWSShard: {
      /** @description ECR repository URLs of the provision shard */
      ecr_repository_urls?: string[];
      /** @description Backup configurations for the provision shard */
      backup_configs?: components['schemas']['AWSBackupConfig'][];
    };
    /** @description Spot market options for AWS machine pool. */
    AWSSpotMarketOptions: {
      /** @description Indicates the type of this object. Will be 'AWSSpotMarketOptions' if this is a complete object or 'AWSSpotMarketOptionsLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: float
       * @description The max price for spot instance. Optional.
       *     If not set, use the on-demand price.
       */
      max_price?: number;
    };
    /** @description Holds settings for an AWS storage volume. */
    AWSVolume: {
      /**
       * Format: int32
       * @description Volume provisioned IOPS.
       */
      iops?: number;
      /**
       * Format: int32
       * @description Volume size in Gib.
       */
      size?: number;
    };
    /** @description Representation of an sts account role for a rosa cluster */
    AWSSTSAccountRole: {
      /** @description The list of STS Roles for this Account Role */
      items?: components['schemas']['AWSSTSRole'][];
      /** @description The Prefix for this Account Role */
      prefix?: string;
    };
    /** @description Representation of an sts policies for rosa cluster */
    AWSSTSPolicy: {
      /** @description The ARN of the managed policy */
      arn?: string;
      /** @description Policy ID */
      id?: string;
      /** @description Policy Details */
      details?: string;
      /** @description Type of policy operator/account role */
      type?: string;
    };
    /** @description Representation of an sts role for a rosa cluster */
    AWSSTSRole: {
      /** @description Does this Role have HCP Managed Policies? */
      hcpManagedPolicies?: boolean;
      /** @description Does this role have Admin permission? */
      isAdmin?: boolean;
      /** @description Does this Role have Managed Policies? */
      managedPolicies?: boolean;
      /** @description The AWS ARN for this Role */
      arn?: string;
      /** @description The type of this Role */
      type?: string;
      /** @description The Openshift Version for this Role */
      roleVersion?: string;
    };
    CCS: {
      /** @description Indicates the type of this object. Will be 'CCS' if this is a complete object or 'CCSLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Indicates if cloud permissions checks are disabled,
       *     when attempting installation of the cluster. */
      disable_scp_checks?: boolean;
      /** @description Indicates if Customer Cloud Subscription is enabled on the cluster. */
      enabled?: boolean;
    };
    /** @description Describes the CIDR Block access policy to the Kubernetes API server.
     *     Currently, only supported for ARO-HCP based clusters.
     *     The default policy mode is "allow_all" that is, all access is allowed. */
    CIDRBlockAccess: {
      allow?: components['schemas']['CIDRBlockAllowAccess'];
    };
    CIDRBlockAllowAccess: {
      /** @description There are two modes: "allow_all" and "allow_list"; if "allow_list" is provided than a non-empty 'values' list must be provided.
       *     Otherwise, if "allow_all" is provided then 'values' list should be omitted. */
      mode?: string;
      /** @description The 'values' list should contain a CIDR block list (An IPV4 address range in the format `<ipv4_address>/<network_mask>`).
       *     The maximum number of CIDR blocks supported is 500. The CIDR blocks should be non-overlapping and valid.
       *     The value "0.0.0.0/0" is not considered a valid value, as the user can use "allow_all" mode to indicate this behavior.
       *     The values should not contain the set of Private IP address ranges. */
      values?: string[];
    };
    /** @description Representation of information from telemetry about a the CPU capacity by node role and OS. */
    CPUTotalNodeRoleOSMetricNode: {
      /**
       * Format: float
       * @description The total CPU capacity of nodes with this set of roles and operating system.
       */
      cpu_total?: number;
      /** @description Representation of the node role for a cluster. */
      node_roles?: string[];
      /** @description The operating system. */
      operating_system?: string;
      /** Format: date-time */
      time?: string;
    };
    /** @description Representation of information from telemetry about the CPU capacity by node
     *     role and OS of a cluster. */
    CPUTotalsNodeRoleOSMetricNode: {
      cpu_totals?: components['schemas']['CPUTotalNodeRoleOSMetricNode'][];
    };
    /** @description DNS settings of the cluster. */
    DNS: {
      /** @description Base DNS domain of the cluster.
       *
       *     During the installation of the cluster it is necessary to create multiple DNS records.
       *     They will be created as sub-domains of this domain. For example, if the domain_prefix of the
       *     cluster is `mycluster` and the base domain is `example.com` then the following DNS
       *     records will be created:
       *
       *     ```
       *     mycluster-api.example.com
       *     mycluster-etcd-0.example.com
       *     mycluster-etcd-1.example.com
       *     mycluster-etcd-3.example.com
       *     ```
       *
       *     The exact number, type and names of the created DNS record depends on the characteristics
       *     of the cluster, and may be different for different versions of _OpenShift_. Please don't
       *     rely on them. For example, to find what is the URL of the Kubernetes API server of the
       *     cluster don't assume that it will be `mycluster-api.example.com`. Instead of that use
       *     this API to retrieve the description of the cluster, and get it from the `api.url`
       *     attribute. For example, if the identifier of the cluster is `123` send a request like
       *     this:
       *
       *     ```http
       *     GET /api/clusters_mgmt/v1/clusters/123 HTTP/1.1
       *     ```
       *
       *     That will return a response like this, including the `api.url` attribute:
       *
       *     ```json
       *     {
       *         "kind": "Cluster",
       *         "id": "123",
       *         "href": "/api/clusters_mgmt/v1/clusters/123",
       *             "api": {
       *             "url": "https://mycluster-api.example.com:6443"
       *         },
       *         ...
       *     }
       *     ```
       *
       *     When the cluster is created in Amazon Web Services it is necessary to create this base
       *     DNS domain in advance, using AWS Route53 (https://console.aws.amazon.com/route53). */
      base_domain?: string;
    };
    /** @description Contains the properties of a DNS domain. */
    DNSDomain: {
      /** @description Indicates the type of this object. Will be 'DNSDomain' if this is a complete object or 'DNSDomainLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Link to the cluster that is registered with the DNS domain (optional). */
      cluster?: components['schemas']['ClusterLink'];
      /** @description Signals which cluster architecture the domain is ready for. */
      cluster_arch?: components['schemas']['ClusterArchitecture'];
      /** @description Link to the organization that reserved the DNS domain. */
      organization?: components['schemas']['OrganizationLink'];
      /**
       * Format: date-time
       * @description Date and time when the DNS domain was reserved.
       */
      reserved_at_timestamp?: string;
      /** @description Indicates if this dns domain is user defined. */
      user_defined?: boolean;
    };
    /** @description Google cloud platform settings of a cluster. */
    GCP: {
      /** @description GCP authentication uri */
      auth_uri?: string;
      /** @description GCP Authentication provider x509 certificate url */
      auth_provider_x509_cert_url?: string;
      /** @description GCP Authentication Method */
      authentication?: components['schemas']['GcpAuthentication'];
      /** @description GCP client identifier */
      client_id?: string;
      /** @description GCP client x509 certificate url */
      client_x509_cert_url?: string;
      /** @description GCP client email */
      client_email?: string;
      /** @description GCP private key */
      private_key?: string;
      /** @description GCP private key identifier */
      private_key_id?: string;
      /** @description GCP PrivateServiceConnect configuration */
      private_service_connect?: components['schemas']['GcpPrivateServiceConnect'];
      /** @description GCP project identifier. */
      project_id?: string;
      /** @description GCP Security Settings */
      security?: components['schemas']['GcpSecurity'];
      /** @description GCP token uri */
      token_uri?: string;
      /** @description GCP the type of the service the key belongs to */
      type?: string;
    };
    /** @description GCP Encryption Key for CCS clusters. */
    GCPEncryptionKey: {
      /** @description Service account used to access the KMS key */
      kms_key_service_account?: string;
      /** @description Location of the encryption key ring */
      key_location?: string;
      /** @description Name of the encryption key */
      key_name?: string;
      /** @description Name of the key ring the encryption key is located on */
      key_ring?: string;
    };
    /** @description Specification for different classes of nodes inside a flavour. */
    GCPFlavour: {
      /** @description GCP default instance type for the worker volume.
       *
       *     User can be overridden specifying in the cluster itself a type for compute node. */
      compute_instance_type?: string;
      /** @description GCP default instance type for the infra volume. */
      infra_instance_type?: string;
      /** @description Infra volume specification. */
      infra_volume?: components['schemas']['GCPVolume'];
      /** @description GCP default instance type for the master volume. */
      master_instance_type?: string;
      /** @description Master volume specification. */
      master_volume?: components['schemas']['GCPVolume'];
      /** @description Worker volume specification. */
      worker_volume?: components['schemas']['GCPVolume'];
    };
    /** @description GcpImageOverride specifies what a GCP VM Image should be used for a particular product and billing model */
    GCPImageOverride: {
      /** @description Indicates the type of this object. Will be 'GCPImageOverride' if this is a complete object or 'GCPImageOverrideLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Link to the billing model. */
      billing_model?: components['schemas']['BillingModelItem'];
      /** @description ImageID is the id of the Google Cloud Platform image. */
      image_id?: string;
      /** @description Link to the product type. */
      product?: components['schemas']['Product'];
      /** @description ProjectID is the id of the Google Cloud Platform project that hosts the image. */
      project_id?: string;
    };
    /** @description Representation of gcp machine pool specific parameters. */
    GCPMachinePool: {
      /** @description Determines whether the Shielded VM's SecureBoot feature should be
       *     enabled for the nodes of the machine pool. If SecureBoot is not
       *     specified, the value of this attribute will remain unspecified and the
       *     SecureBoot's value specified in the `.gcp.security.secure_boot`
       *     attribute of the parent Cluster will be the one applied to the nodes of
       *     the machine pool.
       *     Immutable. */
      secure_boot?: boolean;
    };
    /** @description GCP Network configuration of a cluster. */
    GCPNetwork: {
      /** @description VPC mame used by the cluster. */
      vpc_name?: string;
      /** @description The name of the host project where the shared VPC exists. */
      vpc_project_id?: string;
      /** @description Compute subnet used by the cluster. */
      compute_subnet?: string;
      /** @description Control plane subnet used by the cluster. */
      control_plane_subnet?: string;
    };
    /** @description Holds settings for an GCP storage volume. */
    GCPVolume: {
      /**
       * Format: int32
       * @description Volume size in Gib.
       */
      size?: number;
    };
    /** @description Details for `htpasswd` identity providers. */
    HTPasswdIdentityProvider: {
      /** @description Password to be used in the _HTPasswd_ data file. */
      password?: string;
      /** @description Username to be used in the _HTPasswd_ data file. */
      username?: string;
      /** @description Link to the collection of _HTPasswd_ users. */
      users?: components['schemas']['HTPasswdUser'][];
    };
    HTPasswdUser: {
      /** @description ID for a secondary user in the _HTPasswd_ data file. */
      id?: string;
      /** @description HTPasswd Hashed Password for a user in the _HTPasswd_ data file.
       *     The value of this field is set as-is in the _HTPasswd_ data file for the HTPasswd IDP */
      hashed_password?: string;
      /** @description Password in plain-text for a  user in the _HTPasswd_ data file.
       *     The value of this field is hashed before setting it in the  _HTPasswd_ data file for the HTPasswd IDP */
      password?: string;
      /** @description Username for a secondary user in the _HTPasswd_ data file. */
      username?: string;
    };
    /** @description LDAP attributes used to configure the LDAP identity provider. */
    LDAPAttributes: {
      /** @description List of attributes to use as the identity. */
      id?: string[];
      /** @description List of attributes to use as the mail address. */
      email?: string[];
      /** @description List of attributes to use as the display name. */
      name?: string[];
      /** @description List of attributes to use as the preferred user name when provisioning a user. */
      preferred_username?: string[];
    };
    /** @description Details for `ldap` identity providers. */
    LDAPIdentityProvider: {
      /** @description Certificate bundle to use to validate server certificates for the configured URL. */
      ca?: string;
      /** @description An https://tools.ietf.org/html/rfc2255[RFC 2255] URL which specifies the LDAP host and
       *     search parameters to use. */
      url?: string;
      /** @description LDAP attributes used to configure the provider. */
      attributes?: components['schemas']['LDAPAttributes'];
      /** @description Optional distinguished name to use to bind during the search phase. */
      bind_dn?: string;
      /** @description Optional password to use to bind during the search phase. */
      bind_password?: string;
      /** @description When `true` no TLS connection is made to the server. When `false` `ldaps://...` URLs
       *     connect using TLS and `ldap://...` are upgraded to TLS. */
      insecure?: boolean;
    };
    /** @description Contains the necessary attributes to support role-based authentication on AWS. */
    STS: {
      /** @description URL of the location where OIDC configuration and keys are available */
      oidc_endpoint_url?: string;
      /** @description Auto creation mode for cluster - OCM will create the operator roles and OIDC provider. false by default. */
      auto_mode?: boolean;
      /** @description If STS is enabled or disabled */
      enabled?: boolean;
      /** @description Optional unique identifier when assuming role in another account */
      external_id?: string;
      /** @description Instance IAM roles to use for the instance profiles of the master and worker instances */
      instance_iam_roles?: components['schemas']['InstanceIAMRoles'];
      /** @description If true, cluster account and operator roles have managed policies attached. */
      managed_policies?: boolean;
      /** @description Registered Oidc Config, if available holds information related to the oidc config. */
      oidc_config?: components['schemas']['OidcConfig'];
      /** @description List of roles necessary to access the AWS resources of the various operators used during installation */
      operator_iam_roles?: components['schemas']['OperatorIAMRole'][];
      /** @description Optional user provided prefix for operator roles. */
      operator_role_prefix?: string;
      /** @description Optional user provided permission boundary. */
      permission_boundary?: string;
      /** @description ARN of the AWS role to assume when installing the cluster */
      role_arn?: string;
      /** @description ARN of the AWS role used by SREs to access the cluster AWS account in order to provide support */
      support_role_arn?: string;
    };
    /** @description Representation of an credRequest */
    STSCredentialRequest: {
      /** @description Name of CredRequest */
      name?: string;
      /** @description Operator Details */
      operator?: components['schemas']['STSOperator'];
    };
    /** @description Representation of an sts operator */
    STSOperator: {
      /** @description Maximum ocp version supported */
      max_version?: string;
      /** @description Minimum ocp version supported */
      min_version?: string;
      /** @description Operator Name */
      name?: string;
      /** @description Operator Namespace */
      namespace?: string;
      /** @description Service Accounts */
      service_accounts?: string[];
    };
    /** @description Representation of an add-on that can be installed in a cluster. */
    AddOn: {
      /** @description Indicates the type of this object. Will be 'AddOn' if this is a complete object or 'AddOnLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Common annotations to be applied to all resources created by this addon. */
      common_annotations?: {
        [key: string]: string;
      };
      /** @description Common labels to be applied to all resources created by this addon. */
      common_labels?: {
        [key: string]: string;
      };
      /** @description Additional configs to be used by the addon once its installed in the cluster. */
      config?: components['schemas']['AddOnConfig'];
      /** @description List of credentials requests to authenticate operators to access cloud resources. */
      credentials_requests?: components['schemas']['CredentialRequest'][];
      /** @description Description of the add-on. */
      description?: string;
      /** @description Link to documentation about the add-on. */
      docs_link?: string;
      /** @description Indicates if this add-on can be added to clusters. */
      enabled?: boolean;
      /** @description Indicates if this add-on has external resources associated with it */
      has_external_resources?: boolean;
      /** @description Indicates if this add-on is hidden. */
      hidden?: boolean;
      /** @description Base64-encoded icon representing an add-on. The icon should be in PNG format. */
      icon?: string;
      /** @description The mode in which the addon is deployed. */
      install_mode?: components['schemas']['AddOnInstallMode'];
      /** @description Label used to attach to a cluster deployment when add-on is installed. */
      label?: string;
      /** @description Indicates if add-on is part of a managed service */
      managed_service?: boolean;
      /** @description Name of the add-on. */
      name?: string;
      /** @description Namespaces which are required by this addon. */
      namespaces?: components['schemas']['AddOnNamespace'][];
      /** @description The name of the operator installed by this add-on. */
      operator_name?: string;
      /** @description List of parameters for this add-on. */
      parameters?: components['schemas']['AddOnParameter'][];
      /** @description List of requirements for this add-on. */
      requirements?: components['schemas']['AddOnRequirement'][];
      /**
       * Format: float
       * @description Used to determine how many units of quota an add-on consumes per resource name.
       */
      resource_cost?: number;
      /** @description Used to determine from where to reserve quota for this add-on. */
      resource_name?: string;
      /** @description List of sub operators for this add-on. */
      sub_operators?: components['schemas']['AddOnSubOperator'][];
      /** @description The namespace in which the addon CRD exists. */
      target_namespace?: string;
      /** @description Link to the current default version of this add-on. */
      version?: components['schemas']['AddOnVersion'];
    };
    /** @description Representation of an add-on config.
     *     The attributes under it are to be used by the addon once its installed in the cluster. */
    AddOnConfig: {
      /** @description Indicates the type of this object. Will be 'AddOnConfig' if this is a complete object or 'AddOnConfigLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description List of environment variables for the addon */
      add_on_environment_variables?: components['schemas']['AddOnEnvironmentVariable'][];
      /** @description List of secret propagations for the addon */
      secret_propagations?: components['schemas']['AddOnSecretPropagation'][];
    };
    /** @description Representation of an add-on env object. */
    AddOnEnvironmentVariable: {
      /** @description Indicates the type of this object. Will be 'AddOnEnvironmentVariable' if this is a complete object or 'AddOnEnvironmentVariableLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Name of the env object. */
      name?: string;
      /** @description Value of the env object. */
      value?: string;
    };
    /**
     * @description Representation of an add-on InstallMode field.
     * @enum {string}
     */
    AddOnInstallMode: AddOnInstallMode;
    /** @description Representation of an add-on installation in a cluster. */
    AddOnInstallation: {
      /** @description Indicates the type of this object. Will be 'AddOnInstallation' if this is a complete object or 'AddOnInstallationLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Link to add-on attached to this cluster. */
      addon?: components['schemas']['AddOn'];
      /** @description Link to the installed version of this add-on. */
      addon_version?: components['schemas']['AddOnVersion'];
      /** @description Billing details for add-on installation resource  */
      billing?: components['schemas']['AddOnInstallationBilling'];
      /**
       * Format: date-time
       * @description Date and time when the add-on was initially installed in the cluster.
       */
      creation_timestamp?: string;
      /** @description Version of the operator installed by the add-on. */
      operator_version?: string;
      /** @description List of add-on parameters for this add-on installation. */
      parameters?: components['schemas']['AddOnInstallationParameter'][];
      /** @description Overall state of the add-on installation. */
      state?: components['schemas']['AddOnInstallationState'];
      /** @description Reason for the current State. */
      state_description?: string;
      /**
       * Format: date-time
       * @description Date and time when the add-on installation information was last updated.
       */
      updated_timestamp?: string;
    };
    /** @description Representation of an add-on installation billing. */
    AddOnInstallationBilling: {
      /** @description Indicates the type of this object. Will be 'AddOnInstallationBilling' if this is a complete object or 'AddOnInstallationBillingLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Account ID for billing market place */
      billing_marketplace_account?: string;
      /** @description Billing Model for addon resources */
      billing_model?: components['schemas']['BillingModel'];
    };
    /** @description Representation of an add-on installation parameter. */
    AddOnInstallationParameter: {
      /** @description Indicates the type of this object. Will be 'AddOnInstallationParameter' if this is a complete object or 'AddOnInstallationParameterLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Value of the parameter. */
      value?: string;
    };
    /**
     * @description Representation of an add-on installation State field.
     * @enum {string}
     */
    AddOnInstallationState: AddOnInstallationState;
    AddOnNamespace: {
      /** @description Indicates the type of this object. Will be 'AddOnNamespace' if this is a complete object or 'AddOnNamespaceLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Annotations to be applied to this namespace. */
      annotations?: {
        [key: string]: string;
      };
      /** @description Labels to be applied to this namespace. */
      labels?: {
        [key: string]: string;
      };
      /** @description Name of the namespace. */
      name?: string;
    };
    /** @description Representation of an add-on parameter. */
    AddOnParameter: {
      /** @description Indicates the type of this object. Will be 'AddOnParameter' if this is a complete object or 'AddOnParameterLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Link to add-on. */
      addon?: components['schemas']['AddOn'];
      /** @description Conditions in which this parameter is valid for */
      conditions?: components['schemas']['AddOnRequirement'][];
      /** @description Indicates the value default for the add-on parameter. */
      default_value?: string;
      /** @description Description of the add-on parameter. */
      description?: string;
      /** @description Indicates if this parameter can be edited after creation. */
      editable?: boolean;
      /** @description Restricts if the parameter can be upscaled/downscaled
       *     Expected values are "up", "down", or "" (no restriction). */
      editable_direction?: string;
      /** @description Indicates if this parameter is enabled for the add-on. */
      enabled?: boolean;
      /** @description Name of the add-on parameter. */
      name?: string;
      /** @description List of options for the add-on parameter value. */
      options?: components['schemas']['AddOnParameterOption'][];
      /** @description Indicates if this parameter is required by the add-on. */
      required?: boolean;
      /** @description Validation rule for the add-on parameter. */
      validation?: string;
      /** @description Error message to return should the parameter be invalid. */
      validation_err_msg?: string;
      /** @description Type of value of the add-on parameter. */
      value_type?: string;
    };
    /** @description Representation of an add-on parameter option. */
    AddOnParameterOption: {
      /** @description Name of the add-on parameter option. */
      name?: string;
      /**
       * Format: int32
       * @description Rank of option to be used in cases where editable direction should be restricted.
       */
      rank?: number;
      /** @description List of add-on requirements for this parameter option. */
      requirements?: components['schemas']['AddOnRequirement'][];
      /** @description Value of the add-on parameter option. */
      value?: string;
    };
    /** @description Representation of an add-on requirement. */
    AddOnRequirement: {
      /** @description ID of the add-on requirement. */
      id?: string;
      /** @description Data for the add-on requirement. */
      data?: {
        [key: string]: Record<string, never>;
      };
      /** @description Indicates if this requirement is enabled for the add-on. */
      enabled?: boolean;
      /** @description Type of resource of the add-on requirement. */
      resource?: string;
      /** @description Optional cluster specific status for the add-on. */
      status?: components['schemas']['AddOnRequirementStatus'];
    };
    /** @description Representation of an add-on requirement status. */
    AddOnRequirementStatus: {
      /** @description Error messages detailing reasons for unfulfilled requirements. */
      error_msgs?: string[];
      /** @description Indicates if this requirement is fulfilled. */
      fulfilled?: boolean;
    };
    /** @description Representation of an addon secret propagation */
    AddOnSecretPropagation: {
      /** @description ID of the secret propagation */
      id?: string;
      /** @description DestinationSecret is location of the secret to be added */
      destination_secret?: string;
      /** @description Indicates is this secret propagation is enabled for the addon */
      enabled?: boolean;
      /** @description SourceSecret is location of the source secret */
      source_secret?: string;
    };
    /** @description Representation of an add-on sub operator. A sub operator is an operator
     *     who's life cycle is controlled by the add-on umbrella operator.  */
    AddOnSubOperator: {
      /** @description Indicates if the sub operator is enabled for the add-on */
      enabled?: boolean;
      /** @description Name of the add-on sub operator */
      operator_name?: string;
      /** @description Namespace of the add-on sub operator */
      operator_namespace?: string;
    };
    /** @description Representation of an add-on version. */
    AddOnVersion: {
      /** @description Indicates the type of this object. Will be 'AddOnVersion' if this is a complete object or 'AddOnVersionLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Additional catalog sources associated with this addon version */
      additional_catalog_sources?: components['schemas']['AdditionalCatalogSource'][];
      /** @description AvailableUpgrades is the list of versions this version can be upgraded to. */
      available_upgrades?: string[];
      /** @description The specific addon catalog source channel of packages */
      channel?: string;
      /** @description Additional configs to be used by the addon once its installed in the cluster. */
      config?: components['schemas']['AddOnConfig'];
      /** @description Indicates if this add-on version can be added to clusters. */
      enabled?: boolean;
      /** @description The package image for this addon version */
      package_image?: string;
      /** @description List of parameters for this add-on version. */
      parameters?: components['schemas']['AddOnParameter'][];
      /** @description The pull secret name used for this addon version. */
      pull_secret_name?: string;
      /** @description List of requirements for this add-on version. */
      requirements?: components['schemas']['AddOnRequirement'][];
      /** @description The catalog source image for this add-on version. */
      source_image?: string;
      /** @description List of sub operators for this add-on version. */
      sub_operators?: components['schemas']['AddOnSubOperator'][];
    };
    /** @description Representation of an addon catalog source object used by addon versions. */
    AdditionalCatalogSource: {
      /** @description ID of the additional catalog source */
      id?: string;
      /** @description Indicates is this additional catalog source is enabled for the addon */
      enabled?: boolean;
      /** @description Image of the additional catalog source. */
      image?: string;
      /** @description Name of the additional catalog source. */
      name?: string;
    };
    /** @description Representation of an upgrade policy that can be set for a cluster. */
    AddonUpgradePolicy: {
      /** @description Indicates the type of this object. Will be 'AddonUpgradePolicy' if this is a complete object or 'AddonUpgradePolicyLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Addon ID this upgrade policy is defined for */
      addon_id?: string;
      /** @description Cluster ID this upgrade policy is defined for. */
      cluster_id?: string;
      /**
       * Format: date-time
       * @description Next time the upgrade should run.
       */
      next_run?: string;
      /** @description Schedule cron expression that defines automatic upgrade scheduling. */
      schedule?: string;
      /** @description Schedule type can be either "manual" (single execution) or "automatic" (re-occurring). */
      schedule_type?: string;
      /** @description Upgrade type specify the type of the upgrade. Must be "ADDON". */
      upgrade_type?: string;
      /** @description Version is the desired upgrade version. */
      version?: string;
    };
    /** @description Representation of an addon upgrade policy state that that is set for a cluster. */
    AddonUpgradePolicyState: {
      /** @description Indicates the type of this object. Will be 'AddonUpgradePolicyState' if this is a complete object or 'AddonUpgradePolicyStateLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Description of the state. */
      description?: string;
      /** @description State value can be 'pending', 'scheduled', 'cancelled', 'started', 'delayed',
       *     'failed' or 'completed'. */
      value?: components['schemas']['UpgradePolicyStateValue'];
    };
    /** @description Temporary administrator credentials generated during the installation of the
     *     cluster. */
    AdminCredentials: {
      /** @description Cluster administrator password. */
      password?: string;
      /** @description Cluster administrator user name. */
      user?: string;
    };
    /** @description Provides information about a single alert firing on the cluster. */
    AlertInfo: {
      /** @description The alert name. Multiple alerts with same name are possible. */
      name?: string;
      /** @description The alert severity. */
      severity?: components['schemas']['AlertSeverity'];
    };
    /**
     * @description Severity of a cluster alert received via telemetry.
     * @enum {string}
     */
    AlertSeverity: AlertSeverity;
    /** @description Provides information about the alerts firing on the cluster. */
    AlertsInfo: {
      alerts?: components['schemas']['AlertInfo'][];
    };
    /** @description Contains the necessary attributes to support audit log forwarding */
    AuditLog: {
      /** @description ARN of the CloudWatch audit log forwarding role */
      role_arn?: string;
    };
    AutoscalerResourceLimits: {
      /** @description Minimum and maximum number of different GPUs in cluster, in the format <gpu_type>:<min>:<max>.
       *     Cluster autoscaler will not scale the cluster beyond these numbers. Can be passed multiple times. */
      gpus?: components['schemas']['AutoscalerResourceLimitsGPULimit'][];
      /** @description Minimum and maximum number of cores in cluster, in the format <min>:<max>.
       *     Cluster autoscaler will not scale the cluster beyond these numbers. */
      cores?: components['schemas']['ResourceRange'];
      /**
       * Format: int32
       * @description Maximum number of nodes in all node groups.
       *     Cluster autoscaler will not grow the cluster beyond this number.
       */
      max_nodes_total?: number;
      /** @description Minimum and maximum number of gigabytes of memory in cluster, in the format <min>:<max>.
       *     Cluster autoscaler will not scale the cluster beyond these numbers. */
      memory?: components['schemas']['ResourceRange'];
    };
    AutoscalerResourceLimitsGPULimit: {
      range?: components['schemas']['ResourceRange'];
      /** @description The type of GPU to associate with the minimum and maximum limits.
       *     This value is used by the Cluster Autoscaler to identify Nodes that will have GPU capacity by searching
       *     for it as a label value on the Node objects. For example, Nodes that carry the label key
       *     `cluster-api/accelerator` with the label value being the same as the Type field will be counted towards
       *     the resource limits by the Cluster Autoscaler. */
      type?: string;
    };
    AutoscalerScaleDownConfig: {
      /** @description How long after scale up that scale down evaluation resumes. */
      delay_after_add?: string;
      /** @description How long after node deletion that scale down evaluation resumes, defaults to scan-interval. */
      delay_after_delete?: string;
      /** @description How long after scale down failure that scale down evaluation resumes. */
      delay_after_failure?: string;
      /** @description Should cluster-autoscaler scale down the cluster. */
      enabled?: boolean;
      /** @description How long a node should be unneeded before it is eligible for scale down. */
      unneeded_time?: string;
      /** @description Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down. */
      utilization_threshold?: string;
    };
    /** @description AWS provider configuration settings when using AutoNode on a ROSA HCP Cluster */
    AwsAutoNode: {
      /** @description The AWS ARN of the IAM Role that has the permissions required for the AutoNode
       *     controller.
       *     The role must exist prior to enabling AutoNode on the cluster. */
      role_arn?: string;
    };
    /** @description Contains the necessary attributes to support etcd encryption for AWS based clusters. */
    AwsEtcdEncryption: {
      /** @description ARN of the KMS to be used for the etcd encryption */
      kms_key_arn?: string;
    };
    /** @description Microsoft Azure settings of a cluster. */
    Azure: {
      /** @description Etcd encryption configuration.
       *     If not specified, etcd data is encrypted with platform managed keys.
       *     Currently etcd data encryption is only supported with customer managed keys.
       *     Creating a cluster with platform managed keys will result in a failure creating the cluster. */
      etcd_encryption?: components['schemas']['AzureEtcdEncryption'];
      /** @description The desired name of the Azure Resource Group where the Azure Resources related
       *     to the cluster are created. It must not previously exist. The Azure Resource
       *     Group is created with the given value, within the Azure Subscription
       *     `subscription_id` of the cluster.
       *     `managed_resource_group_name` cannot be equal to the value of `managed_resource_group`.
       *     `managed_resource_group_name` is located in the same Azure location as the
       *     cluster's region.
       *     Not to be confused with `resource_group_name`, which is the Azure Resource Group Name
       *     where the own Azure Resource associated to the cluster resides.
       *     Required during creation.
       *     Immutable. */
      managed_resource_group_name?: string;
      /** @description The Azure Resource ID of a pre-existing Azure Network Security Group.
       *     The Network Security Group specified in network_security_group_resource_id
       *     must already be associated to the Azure Subnet `subnet_resource_id`.
       *     It is the Azure Network Security Group associated to the cluster's subnet
       *     specified in `subnet_resource_id`.
       *     `network_security_group_resource_id` must be located in the same Azure
       *     location as the cluster's region.
       *     The Azure Subscription specified as part of
       *     `network_security_group_resource_id` must be located in the same Azure
       *     Subscription as `subscription_id`.
       *     The Azure Resource Group Name specified as part of `network_security_group_resource_id`
       *     must belong to the Azure Subscription `subscription_id`, and in the same
       *     Azure location as the cluster's region.
       *     The Azure Resource Group Name specified as part of `network_security_group_resource_id`
       *     must be a different Resource Group Name than the one specified in
       *     `managed_resource_group_name`.
       *     The Azure Resource Group Name specified as part of `network_security_group_resource_id`
       *     can be the same, or a different one than the one specified in
       *     `resource_group_name`.
       *     Required during creation.
       *     Immutable. */
      network_security_group_resource_id?: string;
      /** @description NodesOutboundConnectivity defines how the network outbound
       *     configuration of the Cluster's Node Pool's Nodes is performed.
       *     By default this is configured as Azure Load Balancer. This value is immutable. */
      nodes_outbound_connectivity?: components['schemas']['AzureNodesOutboundConnectivity'];
      /** @description Defines how the operators of the cluster authenticate to Azure.
       *     Required during creation.
       *     Immutable. */
      operators_authentication?: components['schemas']['AzureOperatorsAuthentication'];
      /** @description The Azure Resource Group Name of the cluster. It must be a pre-existing
       *     Azure Resource Group and it must exist within the Azure Subscription
       *     `subscription_id` of the cluster.
       *     `resource_group_name` is located in the same Azure location as the
       *     cluster's region.
       *     Required during creation.
       *     Immutable. */
      resource_group_name?: string;
      /** @description The Azure Resource Name of the cluster. It must be within the
       *     Azure Resource Group Name `resource_group_name`.
       *     `resource_name` is located in the same Azure location as the cluster's region.
       *     Required during creation.
       *     Immutable. */
      resource_name?: string;
      /** @description The Azure Resource ID of a pre-existing Azure Subnet. It is an Azure
       *     Subnet used for the Data Plane of the cluster. `subnet_resource_id`
       *     must be located in the same Azure location as the cluster's region.
       *     The Azure Subscription specified as part of the `subnet_resource_id`
       *     must be located in the same Azure Subscription as `subscription_id`.
       *     The Azure Resource Group Name specified as part of `subnet_resource_id`
       *     must belong to the Azure Subscription `subscription_id`, and in the same
       *     Azure location as the cluster's region.
       *     The Azure Resource Group Name specified as part of `subnet_resource_id`
       *     must be a different Resource Group Name than the one specified in
       *     `managed_resource_group_name`.
       *     The Azure Resource Group Name specified as part of the `subnet_resource_id`
       *     can be the same, or a different one than the one specified in
       *     `resource_group_name`.
       *     Required during creation.
       *     Immutable. */
      subnet_resource_id?: string;
      /** @description The Azure Subscription ID associated with the cluster. It must belong to
       *     the Microsoft Entra Tenant ID `tenant_id`.
       *     Required during creation.
       *     Immutable. */
      subscription_id?: string;
      /** @description The Microsoft Entra Tenant ID where the cluster belongs.
       *     Required during creation.
       *     Immutable. */
      tenant_id?: string;
    };
    /** @description Represents the information associated to an Azure User-Assigned
     *     Managed Identity belonging to the Control Plane of the cluster. */
    AzureControlPlaneManagedIdentity: {
      /** @description The Client ID associated to the Azure User-Assigned Managed Identity.
       *     Readonly. */
      client_id?: string;
      /** @description The Principal ID associated to the Azure User-Assigned Identity.
       *     Readonly. */
      principal_id?: string;
      /** @description The Azure Resource ID of the Azure User-Assigned Managed
       *     Identity. The managed identity represented must exist before
       *     creating the cluster.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     must belong to the Azure Subscription specified in `.azure.subscription_id`,
       *     and in the same Azure location as the cluster's region.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     must be a different Resource Group Name than the one specified in
       *     `.azure.managed_resource_group_name`.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     can be the same, or a different one than the one specified in
       *     `.azure.resource_group_name`.
       *     Required during creation.
       *     Immutable. */
      resource_id?: string;
    };
    /** @description Represents the information associated to an Azure User-Assigned
     *     Managed Identity belonging to the Data Plane of the cluster. */
    AzureDataPlaneManagedIdentity: {
      /** @description The Azure Resource ID of the Azure User-Assigned Managed
       *     Identity. The managed identity represented must exist before
       *     creating the cluster.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     must belong to the Azure Subscription specified in `.azure.subscription_id`,
       *     and in the same Azure location as the cluster's region.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     must be a different Resource Group Name than the one specified in
       *     `.azure.managed_resource_group_name`.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     can be the same, or a different one than the one specified in
       *     `.azure.resource_group_name`.
       *     Required during creation.
       *     Immutable. */
      resource_id?: string;
    };
    /** @description Contains the necessary attributes to support data encryption for Azure based clusters. */
    AzureEtcdDataEncryption: {
      /** @description Customer Managed encryption keys configuration.
       *     Required when key_management_mode is "customer_managed". */
      customer_managed?: components['schemas']['AzureEtcdDataEncryptionCustomerManaged'];
      /** @description The key management strategy used for the encryption key that encrypts the etcd data.
       *     Accepted values are: "customer_managed", "platform_managed".
       *     By default, "platform_managed" is used.
       *     Currently only "customer_managed" mode is supported. */
      key_management_mode?: string;
    };
    /** @description Contains the necessary attributes to support etcd data encryption with customer managed keys
     *     for Azure based clusters. */
    AzureEtcdDataEncryptionCustomerManaged: {
      /** @description The encryption type used.
       *     Accepted values are: "kms".
       *     By default, "kms" is used. */
      encryption_type?: string;
      /** @description The KMS encryption configuration.
       *     Required when encryption_type is "kms". */
      kms?: components['schemas']['AzureKmsEncryption'];
    };
    /** @description Contains the necessary attributes to support etcd encryption for Azure based clusters. */
    AzureEtcdEncryption: {
      /** @description etcd data encryption settings.
       *     If not specified, etcd data is encrypted with platform managed keys. */
      data_encryption?: components['schemas']['AzureEtcdDataEncryption'];
    };
    /** @description Contains the necessary attributes to support KMS encryption for Azure based clusters. */
    AzureKmsEncryption: {
      /** @description The details of the active key
       *     Required during creation. */
      active_key?: components['schemas']['AzureKmsKey'];
    };
    /** @description Contains the necessary attributes to support KMS encryption key for Azure based clusters */
    AzureKmsKey: {
      /** @description key_name is the name of the Azure Key Vault Key
       *     Required during creation. */
      key_name?: string;
      /** @description key_vault_name is the name of the Azure Key Vault that contains the encryption key
       *     Required during creation. */
      key_vault_name?: string;
      /** @description key_version is the version of the Azure Key Vault key
       *     Required during creation. */
      key_version?: string;
    };
    /** @description Representation of azure node pool specific parameters. */
    AzureNodePool: {
      /** @description The Azure Virtual Machine size identifier used for the
       *     Nodes of the Node Pool.
       *     Availability of VM sizes are dependent on the Azure Location
       *     of the parent Cluster.
       *     Required during creation. */
      vm_size?: string;
      /** @description EncryptionAtHost contains Encryption At Host disk encryption configuration.
       *     When enabled, it enhances Azure Disk Storage Server-Side Encryption to ensure that all temporary disks
       *     and disk caches are encrypted at rest and flow encrypted to the Storage clusters.
       *     If not specified, Encryption at Host is not enabled.
       *     Immutable. */
      encryption_at_host?: components['schemas']['AzureNodePoolEncryptionAtHost'];
      /** @description The configuration for the OS disk used by the nodes in the Node Pool. */
      os_disk?: components['schemas']['AzureNodePoolOsDisk'];
      /** @description ResourceName is the Azure Resource Name of the NodePool.
       *     ResourceName must be within the Azure Resource Group Name of the parent
       *     Cluster it belongs to.
       *     ResourceName must be located in the same Azure Location as the parent
       *     Cluster it belongs to.
       *     ResourceName must be located in the same Azure Subscription as the parent
       *     Cluster it belongs to.
       *     ResourceName must belong to the same Microsoft Entra Tenant ID as the parent
       *     Cluster it belongs to.
       *     Required during creation.
       *     Immutable. */
      resource_name?: string;
    };
    /** @description AzureNodePoolEncryptionAtHost defines the encryption setting for Encryption At Host.
     *     If not specified, Encryption at Host is not enabled. */
    AzureNodePoolEncryptionAtHost: {
      /** @description State indicates whether Encryption At Host is enabled.
       *     When enabled, it enhances Azure Disk Storage Server-Side Encryption to ensure that all temporary disks
       *     and disk caches are encrypted at rest and flow encrypted to the Storage clusters.
       *     Accepted values are: "disabled" or "enabled".
       *     If not specified, its value is "disabled", which indicates Encryption At Host is disabled.
       *     Immutable. */
      state?: string;
    };
    /** @description Defines the configuration of a Node Pool's OS disk. */
    AzureNodePoolOsDisk: {
      /** @description Specifies the OS Disk persistence for the OS Disks of the Nodes in the Node Pool.
       *     Valid values are:
       *     * persistent
       *     * ephemeral
       *     If not specified, Persistent OS Disks are used. */
      persistence?: string;
      /**
       * Format: int32
       * @description The size in GiB to assign to the OS disks of the
       *     Nodes in the Node Pool. The property
       *     is the number of bytes x 1024^3.
       *     If not specified, OS disk size is 64 GiB.
       */
      size_gibibytes?: number;
      /** @description The Azure Resource ID of a pre-existing Azure Disk Encryption Set (DES).
       *     When provided, Server-Side Encryption (SSE) on the OS Disks of the Nodes of the Node Pool
       *     is performed using the provided Disk Encryption Set.
       *     It must be located in the same Azure location as the parent Cluster.
       *     It must be located in the same Azure Subscription as the parent Cluster.
       *     The Azure Resource Group Name specified as part of it must be a different resource group name
       *     than the one specified in the parent Cluster's `managed_resource_group_name`.
       *     The Azure Resource Group Name specified as part of it can be the same, or a different one
       *     than the one specified in the parent Cluster's `resource_group_name`.
       *     If not specified, Server-Side Encryption (SSE) on the OS Disks of the Nodes of the Node Pool
       *     is performed with platform managed keys. */
      sse_encryption_set_resource_id?: string;
      /** @description The disk storage account type to use for the OS disks of the Nodes in the
       *     Node Pool. Valid values are:
       *     * Standard_LRS: HDD
       *     * StandardSSD_LRS: Standard SSD
       *     * Premium_LRS: Premium SDD
       *     * UltraSSD_LRS: Ultra SDD
       *
       *     If not specified, `Premium_LRS` is used. */
      storage_account_type?: string;
    };
    /** @description The configuration of the node outbound connectivity */
    AzureNodesOutboundConnectivity: {
      /** @description OutboundType is the type of network outbound configuration.
       *     The default and only accepted value is 'load_balancer'.
       *     This value is immutable. */
      outbound_type?: string;
    };
    /** @description The configuration that the operators of the
     *     cluster have to authenticate to Azure. */
    AzureOperatorsAuthentication: {
      /** @description The authentication configuration to authenticate
       *     to Azure using Azure User-Assigned Managed Identities.
       *     Required during creation. */
      managed_identities?: components['schemas']['AzureOperatorsAuthenticationManagedIdentities'];
    };
    /** @description Represents the information related to Azure User-Assigned managed identities
     *     needed to perform Operators authentication based on Azure User-Assigned
     *     Managed Identities */
    AzureOperatorsAuthenticationManagedIdentities: {
      /** @description The set of Azure User-Assigned Managed Identities leveraged for the
       *     Control Plane operators of the cluster. The set of required managed
       *     identities is dependent on the Cluster's OpenShift version.
       *     Immutable */
      control_plane_operators_managed_identities?: {
        [key: string]: components['schemas']['AzureControlPlaneManagedIdentity'];
      };
      /** @description The set of Azure User-Assigned Managed Identities leveraged for the
       *     Data Plane operators of the cluster. The set of required managed
       *     identities is dependent on the Cluster's OpenShift version.
       *     Immutable. */
      data_plane_operators_managed_identities?: {
        [key: string]: components['schemas']['AzureDataPlaneManagedIdentity'];
      };
      /** @description The Managed Identities Data Plane Identity URL associated with the
       *     cluster. It is the URL that will be used to communicate with the
       *     Managed Identities Resource Provider (MI RP).
       *     Required during creation.
       *     Immutable. */
      managed_identities_data_plane_identity_url?: string;
      /** @description The Azure User-Assigned Managed Identity used to perform service
       *     level actions. Specifically:
       *     - Add Federated Identity Credentials to the identities in
       *       `data_plane_operators_managed_identities` that belong to Data
       *       Plane Cluster Operators
       *     - Perform permissions validation for the BYOVNet related resources
       *       associated to the Cluster
       *     Required during creation.
       *     Immutable. */
      service_managed_identity?: components['schemas']['AzureServiceManagedIdentity'];
    };
    /** @description Represents the information associated to an Azure User-Assigned
     *     Managed Identity whose purpose is to perform service level actions. */
    AzureServiceManagedIdentity: {
      /** @description The Client ID associated to the Azure User-Assigned Managed Identity.
       *     Readonly. */
      client_id?: string;
      /** @description The Principal ID associated to the Azure User-Assigned Managed Identity.
       *     Readonly. */
      principal_id?: string;
      /** @description The Azure Resource ID of the Azure User-Assigned Managed
       *     Identity. The managed identity represented must exist before
       *     creating the cluster.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     must belong to the Azure Subscription specified in `.azure.subscription_id`,
       *     and in the same Azure location as the cluster's region.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     must be a different Resource Group Name than the one specified in
       *     `.azure.managed_resource_group_name`.
       *     The Azure Resource Group Name specified as part of the Resource ID
       *     can be the same, or a different one than the one specified in
       *     `.azure.resource_group_name`.
       *     Required during creation.
       *     Immutable. */
      resource_id?: string;
    };
    /** @description Representation of a Backup. */
    Backup: {
      /** @description Indicates the state of the backup.
       *     Accepted values are: "enabled", "disabled". */
      state?: string;
    };
    /**
     * @description Billing model for cluster resources.
     * @enum {string}
     */
    BillingModel: BillingModel;
    /** @description BillingModelItem represents a billing model */
    BillingModelItem: {
      /** @description Indicates the type of this object. Will be 'BillingModelItem' if this is a complete object or 'BillingModelItemLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description BillingModelType is the type of the BillingModel. e.g. standard, marketplace. */
      billing_model_type?: string;
      /** @description Single line description of the billing model. */
      description?: string;
      /** @description User friendly display name of the billing model. */
      display_name?: string;
      /** @description Indicates the marketplace of the billing model. e.g. gcp, aws, etc. */
      marketplace?: string;
    };
    /** @description Representation of a break glass credential. */
    BreakGlassCredential: {
      /** @description Indicates the type of this object. Will be 'BreakGlassCredential' if this is a complete object or 'BreakGlassCredentialLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: date-time
       * @description ExpirationTimestamp is the date and time when the credential will expire.
       */
      expiration_timestamp?: string;
      /** @description Kubeconfig is the generated kubeconfig for this credential. It is only stored in memory */
      kubeconfig?: string;
      /**
       * Format: date-time
       * @description RevocationTimestamp is the date and time when the credential has been revoked.
       */
      revocation_timestamp?: string;
      /** @description Status is the status of this credential */
      status?: components['schemas']['BreakGlassCredentialStatus'];
      /** @description Username is the user which will be used for this credential. */
      username?: string;
    };
    /**
     * @description Status of the break glass credential.
     * @enum {string}
     */
    BreakGlassCredentialStatus: BreakGlassCredentialStatus;
    /** @description ByoOidc configuration. */
    ByoOidc: {
      /** @description Boolean flag indicating if the cluster should be creating using _ByoOidc_.
       *
       *     By default this is `false`.
       *
       *     To enable it the cluster needs to be ROSA cluster and the organization of the user needs
       *     to have the `byo-oidc` feature toggle enabled. */
      enabled?: boolean;
    };
    /** @description The reference of a component that will consume the client configuration. */
    ClientComponent: {
      /** @description The name of the component. */
      name?: string;
      /** @description The namespace of the component. */
      namespace?: string;
    };
    /** @description Description of a cloud provider virtual private cloud. */
    CloudVPC: {
      /** @description List of AWS security groups with details. */
      aws_security_groups?: components['schemas']['SecurityGroup'][];
      /** @description List of AWS subnetworks with details. */
      aws_subnets?: components['schemas']['Subnetwork'][];
      /** @description CIDR block of the virtual private cloud. */
      cidr_block?: string;
      /** @description ID of virtual private cloud. */
      id?: string;
      /** @description Name of virtual private cloud according to its `Name` tag on AWS. */
      name?: string;
      /** @description If the resource is RH managed. */
      red_hat_managed?: boolean;
      /** @description List of subnets used by the virtual private cloud. */
      subnets?: string[];
    };
    /** @description Cloud provider. */
    CloudProvider: {
      /** @description Indicates the type of this object. Will be 'CloudProvider' if this is a complete object or 'CloudProviderLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Name of the cloud provider for display purposes. It can contain any characters,
       *     including spaces. */
      display_name?: string;
      /** @description Human friendly identifier of the cloud provider, for example `aws`. */
      name?: string;
      /** @description (optional) Provider's regions - only included when listing providers with `fetchRegions=true`. */
      regions?: components['schemas']['CloudRegion'][];
    };
    /** @description Description of a cloud provider data used for cloud provider inquiries. */
    CloudProviderData: {
      /** @description Amazon Web Services settings. */
      aws?: components['schemas']['AWS'];
      /** @description Google cloud platform settings. */
      gcp?: components['schemas']['GCP'];
      /** @description Availability zone */
      availability_zones?: string[];
      /** @description Key location */
      key_location?: string;
      /** @description Key ring name */
      key_ring_name?: string;
      /** @description Region */
      region?: components['schemas']['CloudRegion'];
      /** @description Subnets */
      subnets?: string[];
      /** @description Openshift version */
      version?: components['schemas']['Version'];
      /** @description VPC ids */
      vpc_ids?: string[];
    };
    /** @description Description of a region of a cloud provider. */
    CloudRegion: {
      /** @description Indicates the type of this object. Will be 'CloudRegion' if this is a complete object or 'CloudRegionLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description 'true' if the region is supported only for CCS clusters, 'false' otherwise. */
      ccs_only?: boolean;
      /** @description (GCP only) Comma-separated list of KMS location IDs that can be used with this region.
       *     E.g. "global,nam4,us". Order is not guaranteed. */
      kms_location_id?: string;
      /** @description (GCP only) Comma-separated list of display names corresponding to KMSLocationID.
       *     E.g. "Global,nam4 (Iowa, South Carolina, and Oklahoma),US". Order is not guaranteed but will match KMSLocationID.
       *     Unfortunately, this API doesn't allow robust splitting - Contact ocm-feedback@redhat.com if you want to rely on this. */
      kms_location_name?: string;
      /** @description Link to the cloud provider that the region belongs to. */
      cloud_provider?: components['schemas']['CloudProvider'];
      /** @description Name of the region for display purposes, for example `N. Virginia`. */
      display_name?: string;
      /** @description Whether the region is enabled for deploying a managed cluster. */
      enabled?: boolean;
      /** @description Whether the region is an AWS GovCloud region. */
      govcloud?: boolean;
      /** @description Human friendly identifier of the region, for example `us-east-1`.
       *
       *     NOTE: Currently for all cloud providers and all regions `id` and `name` have exactly
       *     the same values. */
      name?: string;
      /** @description 'true' if the region is supported for Hypershift deployments, 'false' otherwise. */
      supports_hypershift?: boolean;
      /** @description Whether the region supports multiple availability zones. */
      supports_multi_az?: boolean;
    };
    /** @description Definition of an _OpenShift_ cluster.
     *
     *     The `cloud_provider` attribute is a reference to the cloud provider. When a
     *     cluster is retrieved it will be a link to the cloud provider, containing only
     *     the kind, id and href attributes:
     *
     *     ```json
     *     {
     *       "cloud_provider": {
     *         "kind": "CloudProviderLink",
     *         "id": "123",
     *         "href": "/api/clusters_mgmt/v1/cloud_providers/123"
     *       }
     *     }
     *     ```
     *
     *     When a cluster is created this is optional, and if used it should contain the
     *     identifier of the cloud provider to use:
     *
     *     ```json
     *     {
     *       "cloud_provider": {
     *         "id": "123",
     *       }
     *     }
     *     ```
     *
     *     If not included, then the cluster will be created using the default cloud
     *     provider, which is currently Amazon Web Services.
     *
     *     The region attribute is mandatory when a cluster is created.
     *
     *     The `aws.access_key_id`, `aws.secret_access_key` and `dns.base_domain`
     *     attributes are mandatory when creation a cluster with your own Amazon Web
     *     Services account. */
    Cluster: {
      /** @description Indicates the type of this object. Will be 'Cluster' if this is a complete object or 'ClusterLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Information about the API of the cluster. */
      api?: components['schemas']['ClusterAPI'];
      /** @description Amazon Web Services settings of the cluster. */
      aws?: components['schemas']['AWS'];
      /** @description List of AWS infrastructure access role grants on this cluster. */
      aws_infrastructure_access_role_grants?: components['schemas']['AWSInfrastructureAccessRoleGrant'][];
      /** @description Contains configuration of a Customer Cloud Subscription cluster. */
      ccs?: components['schemas']['CCS'];
      /** @description DNS settings of the cluster. */
      dns?: components['schemas']['DNS'];
      /** @description Create cluster that uses FIPS Validated / Modules in Process cryptographic libraries. */
      fips?: boolean;
      /** @description Google cloud platform settings of the cluster. */
      gcp?: components['schemas']['GCP'];
      /** @description Key used for encryption of GCP cluster nodes. */
      gcp_encryption_key?: components['schemas']['GCPEncryptionKey'];
      /** @description GCP Network. */
      gcp_network?: components['schemas']['GCPNetwork'];
      /** @description Additional trust bundle. */
      additional_trust_bundle?: string;
      /** @description List of add-ons on this cluster. */
      addons?: components['schemas']['AddOnInstallation'][];
      /** @description The AutoNode settings for this cluster.
       *     This is currently only supported for ROSA HCP */
      auto_node?: components['schemas']['ClusterAutoNode'];
      /** @description Link to an optional _ClusterAutoscaler_ that is coupled with the cluster. */
      autoscaler?: components['schemas']['ClusterAutoscaler'];
      /** @description Microsoft Azure settings of the cluster. */
      azure?: components['schemas']['Azure'];
      /** @description Billing model for cluster resources. */
      billing_model?: components['schemas']['BillingModel'];
      /** @description Contains information about BYO OIDC. */
      byo_oidc?: components['schemas']['ByoOidc'];
      /** @description Link to the cloud provider where the cluster is installed. */
      cloud_provider?: components['schemas']['CloudProvider'];
      /** @description Information about the console of the cluster. */
      console?: components['schemas']['ClusterConsole'];
      /**
       * Format: date-time
       * @description Date and time when the cluster was initially created, using the
       *     format defined in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt).
       */
      creation_timestamp?: string;
      /** @description Delete protection */
      delete_protection?: components['schemas']['DeleteProtection'];
      /** @description Indicates whether the User workload monitoring is enabled or not
       *     It is enabled by default */
      disable_user_workload_monitoring?: boolean;
      /** @description DomainPrefix of the cluster. This prefix is optionally assigned by the user when the
       *     cluster is created. It will appear in the Cluster's domain when the cluster is provisioned. */
      domain_prefix?: string;
      /** @description Indicates whether that etcd is encrypted or not.
       *     This is set only during cluster creation.
       *     For ARO-HCP Clusters, this is a readonly attribute, always set to true. */
      etcd_encryption?: boolean;
      /**
       * Format: date-time
       * @description Date and time when the cluster will be automatically deleted, using the format defined in
       *     [RFC3339](https://www.ietf.org/rfc/rfc3339.txt). If no timestamp is provided, the cluster
       *     will never expire.
       *
       *     This option is unsupported.
       */
      expiration_timestamp?: string;
      /** @description External identifier of the cluster, generated by the installer. */
      external_id?: string;
      /** @description External authentication configuration.
       *
       *     For ROSA HCP, if this is not specified, external authentication configuration will be disabled by default
       *     For ARO HCP, if this is not specified, external authentication configuration will be enabled by default */
      external_auth_config?: components['schemas']['ExternalAuthConfig'];
      /** @description ExternalConfiguration shows external configuration on the cluster. */
      external_configuration?: components['schemas']['ExternalConfiguration'];
      /** @description Link to the _flavour_ that was used to create the cluster. */
      flavour?: components['schemas']['Flavour'];
      /** @description Link to the collection of groups of user of the cluster. */
      groups?: components['schemas']['Group'][];
      /** @description HealthState indicates the overall health state of the cluster. */
      health_state?: components['schemas']['ClusterHealthState'];
      /** @description Details for `htpasswd` identity provider. */
      htpasswd?: components['schemas']['HTPasswdIdentityProvider'];
      /** @description Hypershift configuration. */
      hypershift?: components['schemas']['Hypershift'];
      /** @description Link to the collection of identity providers of the cluster. */
      identity_providers?: components['schemas']['IdentityProvider'][];
      /** @description The OpenShift Image Registry configuration
       *     It provides an internal, integrated container image registry to locally manage images.
       *     For non ARO-HCP clusters, it is readonly and always enabled */
      image_registry?: components['schemas']['ClusterImageRegistry'];
      /** @description List of inflight checks on this cluster. */
      inflight_checks?: components['schemas']['InflightCheck'][];
      /** @description InfraID is used for example to name the VPCs. */
      infra_id?: string;
      /** @description List of ingresses on this cluster. */
      ingresses?: components['schemas']['Ingress'][];
      /** @description Details of cluster-wide KubeletConfig */
      kubelet_config?: components['schemas']['KubeletConfig'];
      /**
       * Format: int32
       * @description Load Balancer quota to be assigned to the cluster.
       */
      load_balancer_quota?: number;
      /** @description List of machine pools on this cluster. */
      machine_pools?: components['schemas']['MachinePool'][];
      /** @description Flag indicating if the cluster is managed (by Red Hat) or
       *     self-managed by the user. */
      managed?: boolean;
      /** @description Contains information about Managed Service */
      managed_service?: components['schemas']['ManagedService'];
      /** @description Flag indicating if the cluster should be created with nodes in
       *     different availability zones or all the nodes in a single one
       *     randomly selected.
       *     For ARO-HCP Clusters, this attribute is unused, and the control plane
       *     is deployed in multiple availability zones when the Azure region where
       *     it is deployed supports multiple availability zones. */
      multi_az?: boolean;
      /** @description Indicate whether the cluster is enabled for multi arch workers */
      multi_arch_enabled?: boolean;
      /** @description Name of the cluster. This name is assigned by the user when the
       *     cluster is created. This is used to uniquely identify the cluster */
      name?: string;
      /** @description Network settings of the cluster. */
      network?: components['schemas']['Network'];
      /** @description Node drain grace period. */
      node_drain_grace_period?: components['schemas']['Value'];
      /** @description List of node pools on this cluster.
       *     NodePool is a scalable set of worker nodes attached to a hosted cluster. */
      node_pools?: components['schemas']['NodePool'][];
      /** @description Information about the nodes of the cluster. */
      nodes?: components['schemas']['ClusterNodes'];
      /** @description Version of _OpenShift_ installed in the cluster, for example `4.0.0-0.2`.
       *
       *     When retrieving a cluster this will always be reported.
       *
       *     When provisioning a cluster this will be ignored, as the version to
       *     deploy will be determined internally. */
      openshift_version?: string;
      /** @description Link to the product type of this cluster. */
      product?: components['schemas']['Product'];
      /** @description User defined properties for tagging and querying. */
      properties?: {
        [key: string]: string;
      };
      /** @description ProvisionShard contains the properties of the provision shard, including AWS and GCP related configurations */
      provision_shard?: components['schemas']['ProvisionShard'];
      /** @description Proxy. */
      proxy?: components['schemas']['Proxy'];
      /** @description Link to the cloud provider region where the cluster is installed. */
      region?: components['schemas']['CloudRegion'];
      /** @description External registry configuration for the cluster */
      registry_config?: components['schemas']['ClusterRegistryConfig'];
      /** @description Overall state of the cluster. */
      state?: components['schemas']['ClusterState'];
      /** @description Status of cluster */
      status?: components['schemas']['ClusterStatus'];
      /** @description Storage quota to be assigned to the cluster. */
      storage_quota?: components['schemas']['Value'];
      /** @description Link to the subscription that comes from the account management service when the cluster
       *     is registered. */
      subscription?: components['schemas']['Subscription'];
      /** @description Link to the version of _OpenShift_ that will be used to install the cluster. */
      version?: components['schemas']['Version'];
    };
    /** @description Information about the API of a cluster. */
    ClusterAPI: {
      /** @description Describes the CIDR Block access policy to the Kubernetes API server. */
      cidr_block_access?: components['schemas']['CIDRBlockAccess'];
      /** @description The URL of the API server of the cluster. */
      url?: string;
      /** @description The listening method of the API server. */
      listening?: components['schemas']['ListeningMethod'];
    };
    /**
     * @description Possible cluster architectures.
     * @enum {string}
     */
    ClusterArchitecture: ClusterArchitecture;
    /** @description The AutoNode configuration for the Cluster. */
    ClusterAutoNode: {
      /** @description Mode indicates the current state of AutoNode on this cluster.
       *     Valid values: "enabled", "disabled". */
      mode?: string;
      status?: components['schemas']['ClusterAutoNodeStatus'];
    };
    /** @description Additional status information on the AutoNode configuration on this Cluster */
    ClusterAutoNodeStatus: {
      /** @description Messages relating to the status of the AutoNode installation on this Cluster */
      message?: string;
    };
    /** @description Cluster-wide autoscaling configuration. */
    ClusterAutoscaler: {
      /** @description Indicates the type of this object. Will be 'ClusterAutoscaler' if this is a complete object or 'ClusterAutoscalerLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description BalanceSimilarNodeGroups enables/disables the
       *     `--balance-similar-node-groups` cluster-autoscaler feature.
       *     This feature will automatically identify node groups with
       *     the same instance type and the same set of labels and try
       *     to keep the respective sizes of those node groups balanced. */
      balance_similar_node_groups?: boolean;
      /** @description This option specifies labels that cluster autoscaler should ignore when considering node group similarity.
       *     For example, if you have nodes with "topology.ebs.csi.aws.com/zone" label, you can add name of this label here
       *     to prevent cluster autoscaler from splitting nodes into different node groups based on its value. */
      balancing_ignored_labels?: string[];
      /** @description Should CA ignore DaemonSet pods when calculating resource utilization for scaling down. false by default. */
      ignore_daemonsets_utilization?: boolean;
      /**
       * Format: int32
       * @description Sets the autoscaler log level.
       *     Default value is 1, level 4 is recommended for DEBUGGING and level 6 will enable almost everything.
       */
      log_verbosity?: number;
      /** @description Maximum time CA waits for node to be provisioned. */
      max_node_provision_time?: string;
      /**
       * Format: int32
       * @description Gives pods graceful termination time before scaling down.
       */
      max_pod_grace_period?: number;
      /**
       * Format: int32
       * @description To allow users to schedule "best-effort" pods, which shouldn't trigger
       *     Cluster Autoscaler actions, but only run when there are spare resources available,
       *     More info: https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-cluster-autoscaler-work-with-pod-priority-and-preemption.
       */
      pod_priority_threshold?: number;
      /** @description Constraints of autoscaling resources. */
      resource_limits?: components['schemas']['AutoscalerResourceLimits'];
      /** @description Configuration of scale down operation. */
      scale_down?: components['schemas']['AutoscalerScaleDownConfig'];
      /** @description Enables/Disables `--skip-nodes-with-local-storage` CA feature flag. If true cluster autoscaler will never delete nodes with pods with local storage, e.g. EmptyDir or HostPath. true by default at autoscaler. */
      skip_nodes_with_local_storage?: boolean;
    };
    /**
     * @description Configuration mode of a cluster.
     * @enum {string}
     */
    ClusterConfigurationMode: ClusterConfigurationMode;
    /** @description Information about the console of a cluster. */
    ClusterConsole: {
      /** @description The URL of the console of the cluster. */
      url?: string;
    };
    /** @description Credentials of the a cluster. */
    ClusterCredentials: {
      /** @description Indicates the type of this object. Will be 'ClusterCredentials' if this is a complete object or 'ClusterCredentialsLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Administrator _kubeconfig_ file for the cluster. */
      kubeconfig?: string;
    };
    /** @description Representation of a clusterdeployment. */
    ClusterDeployment: {
      /** @description Indicates the type of this object. Will be 'ClusterDeployment' if this is a complete object or 'ClusterDeploymentLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Content of the clusterdeployment. */
      content?: Record<string, never>;
    };
    /**
     * @description ClusterHealthState indicates the health of a cluster.
     * @enum {string}
     */
    ClusterHealthState: ClusterHealthState;
    /** @description ClusterImageRegistry represents the configuration for the cluster's internal image registry. */
    ClusterImageRegistry: {
      /** @description State indicates whether the image registry is enabled.
       *     Unless explicitly set, the image registry is enabled by default.
       *     This setting is immutable and cannot be changed after the cluster is created.
       *     Valid values: "enabled", "disabled". */
      state?: string;
    };
    /** @description Definition of a cluster link. */
    ClusterLink: {
      /** @description HREF for the cluster, filled in response. */
      href?: string;
      /** @description The cluster's ID. */
      id?: string;
    };
    /** @description Representation of a cluster migration. */
    ClusterMigration: {
      /** @description Indicates the type of this object. Will be 'ClusterMigration' if this is a complete object or 'ClusterMigrationLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Internal cluster ID. */
      cluster_id?: string;
      /**
       * Format: date-time
       * @description Date and time when the cluster migration was initially created, using the
       *     format defined in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt).
       */
      creation_timestamp?: string;
      /** @description Details for `SdnToOvn` cluster migrations. */
      sdn_to_ovn?: components['schemas']['SdnToOvnClusterMigration'];
      /** @description The state of the cluster migration. */
      state?: components['schemas']['ClusterMigrationState'];
      /** @description Type of cluster migration. The rest of the attributes will be populated according to this
       *     value. For example, if the type is `sdnToOvn` then only the `SdnToOvn` attribute will be
       *     populated. */
      type?: components['schemas']['ClusterMigrationType'];
      /**
       * Format: date-time
       * @description Date and time when the cluster migration was last updated, using the
       *     format defined in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt).
       */
      updated_timestamp?: string;
    };
    /** @description Representation of a cluster migration state. */
    ClusterMigrationState: {
      /** @description A longer description of the current state of the cluster migration. */
      description?: string;
      /** @description The current state of the cluster migration. */
      value?: components['schemas']['ClusterMigrationStateValue'];
    };
    /**
     * @description The state of the cluster migration.
     * @enum {string}
     */
    ClusterMigrationStateValue: ClusterMigrationStateValue;
    /**
     * @description Type of cluster migration.
     * @enum {string}
     */
    ClusterMigrationType: ClusterMigrationType;
    /** @description Counts of different classes of nodes inside a cluster. */
    ClusterNodes: {
      /** @description Details for auto-scaling the compute machine pool.
       *     Compute and AutoscaleCompute cannot be used together. */
      autoscale_compute?: components['schemas']['MachinePoolAutoscaling'];
      /** @description The availability zones upon which the nodes are created. */
      availability_zones?: string[];
      /**
       * Format: int32
       * @description Number of compute nodes of the cluster.
       *     Compute and AutoscaleCompute cannot be used together.
       */
      compute?: number;
      /** @description The labels set on the "default" compute machine pool. */
      compute_labels?: {
        [key: string]: string;
      };
      /** @description The compute machine type to use, for example `r5.xlarge`. */
      compute_machine_type?: components['schemas']['MachineType'];
      /** @description The compute machine root volume capabilities. */
      compute_root_volume?: components['schemas']['RootVolume'];
      /**
       * Format: int32
       * @description Number of infrastructure nodes of the cluster.
       */
      infra?: number;
      /** @description The infra machine type to use, for example `r5.xlarge` (Optional). */
      infra_machine_type?: components['schemas']['MachineType'];
      /**
       * Format: int32
       * @description Number of master nodes of the cluster.
       */
      master?: number;
      /** @description The master machine type to use, for example `r5.xlarge` (Optional). */
      master_machine_type?: components['schemas']['MachineType'];
      /** @description List of security groups to be applied to nodes (Optional). */
      security_group_filters?: components['schemas']['MachinePoolSecurityGroupFilter'][];
      /**
       * Format: int32
       * @description Total number of nodes of the cluster.
       */
      total?: number;
    };
    ClusterOperatorInfo: {
      /** @description Operator status.  Empty string if unknown. */
      condition?: components['schemas']['ClusterOperatorState'];
      /** @description Name of the operator. */
      name?: string;
      /** @description Extra detail on condition, if available.  Empty string if unknown. */
      reason?: string;
      /**
       * Format: date-time
       * @description Time when the sample was obtained, in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format.
       */
      time?: string;
      /** @description Current version of the operator.  Empty string if unknown. */
      version?: string;
    };
    /**
     * @description Overall state of a cluster operator.
     * @enum {string}
     */
    ClusterOperatorState: ClusterOperatorState;
    /** @description Provides detailed information about the operators installed on the cluster. */
    ClusterOperatorsInfo: {
      operators?: components['schemas']['ClusterOperatorInfo'][];
    };
    /** @description Registration of a new cluster to the service.
     *
     *     For example, to register a cluster that has been provisioned outside
     *     of this service, send a a request like this:
     *
     *     ```http
     *     POST /api/clusters_mgmt/v1/register_cluster HTTP/1.1
     *     ```
     *
     *     With a request body like this:
     *
     *     ```json
     *     {
     *       "external_id": "d656aecf-11a6-4782-ad86-8f72638449ba",
     *       "subscription_id": "...",
     *       "organization_id": "..."
     *     }
     *     ``` */
    ClusterRegistration: {
      /** @description Optional Console URL of the cluster. */
      console_url?: string;
      /** @description Identifier of the cluster generated by the installer. */
      external_id?: string;
      /** @description Organization identifier of the cluster generated by the
       *     account manager. */
      organization_id?: string;
      /** @description Subscription identifier of the cluster generated by the account
       *     manager. */
      subscription_id?: string;
    };
    /** @description ClusterRegistryConfig describes the configuration of registries for the cluster.
     *     Its format reflects the OpenShift Image Configuration, for which docs are available on
     *     [docs.openshift.com](https://docs.openshift.com/container-platform/4.16/openshift_images/image-configuration.html)
     *     ```json
     *     {
     *        "registry_config": {
     *          "registry_sources": {
     *            "blocked_registries": [
     *              "badregistry.io",
     *              "badregistry8.io"
     *            ]
     *          }
     *        }
     *     }
     *     ```
     *      */
    ClusterRegistryConfig: {
      /** @description A map containing the registry hostname as the key, and the PEM-encoded certificate as the value,
       *     for each additional registry CA to trust. */
      additional_trusted_ca?: {
        [key: string]: string;
      };
      /** @description AllowedRegistriesForImport limits the container image registries that normal users may import
       *     images from. Set this list to the registries that you trust to contain valid Docker
       *     images and that you want applications to be able to import from. Users with
       *     permission to create Images or ImageStreamMappings via the API are not affected by
       *     this policy - typically only administrators or system integrations will have those
       *     permissions. */
      allowed_registries_for_import?: components['schemas']['RegistryLocation'][];
      /** @description PlatformAllowlist contains a reference to a RegistryAllowlist which is a list of internal registries
       *     which needs to be whitelisted for the platform to work. It can be omitted at creation and
       *     updating and its lifecycle can be managed separately if needed. */
      platform_allowlist?: components['schemas']['RegistryAllowlist'];
      /** @description RegistrySources contains configuration that determines how the container runtime
       *     should treat individual registries when accessing images for builds+pods. (e.g.
       *     whether or not to allow insecure access). It does not contain configuration for the
       *     internal cluster registry. */
      registry_sources?: components['schemas']['RegistrySources'];
    };
    /** @description Cluster Resource which belongs to a cluster, example Cluster Deployment. */
    ClusterResources: {
      /** @description Indicates the type of this object. Will be 'ClusterResources' if this is a complete object or 'ClusterResourcesLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Cluster ID for the fetched resources */
      cluster_id?: string;
      /**
       * Format: date-time
       * @description Date and time when the resources were fetched.
       */
      creation_timestamp?: string;
      /** @description Returned map of cluster resources fetched. */
      resources?: {
        [key: string]: string;
      };
    };
    /**
     * @description Overall state of a cluster.
     * @enum {string}
     */
    ClusterState: ClusterState;
    /** @description Detailed status of a cluster. */
    ClusterStatus: {
      /** @description Indicates the type of this object. Will be 'ClusterStatus' if this is a complete object or 'ClusterStatusLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description DNSReady from Provisioner */
      dns_ready?: boolean;
      /** @description OIDCReady from user configuration. */
      oidc_ready?: boolean;
      /** @description Configuration mode */
      configuration_mode?: components['schemas']['ClusterConfigurationMode'];
      /**
       * Format: int32
       * @description Current Replicas available for a Hosted Cluster
       */
      current_compute?: number;
      /** @description Detailed description of the cluster status. */
      description?: string;
      /**
       * Format: int32
       * @description Limited Support Reason Count
       */
      limited_support_reason_count?: number;
      /** @description Provisioning Error Code */
      provision_error_code?: string;
      /** @description Provisioning Error Message */
      provision_error_message?: string;
      /** @description The overall state of the cluster. */
      state?: components['schemas']['ClusterState'];
    };
    /** @description Representation of a Component Route. */
    ComponentRoute: {
      /** @description Indicates the type of this object. Will be 'ComponentRoute' if this is a complete object or 'ComponentRouteLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Hostname of the route. */
      hostname?: string;
      /** @description TLS Secret reference of the route. */
      tls_secret_ref?: string;
    };
    /**
     * @description Type of Component Route.
     * @enum {string}
     */
    ComponentRouteType: ComponentRouteType;
    /** @description Representation of a Control Plane */
    ControlPlane: {
      /** @description Information about the backup of the control plane */
      backup?: components['schemas']['Backup'];
    };
    /** @description Representation of an upgrade policy that can be set for a cluster. */
    ControlPlaneUpgradePolicy: {
      /** @description Indicates the type of this object. Will be 'ControlPlaneUpgradePolicy' if this is a complete object or 'ControlPlaneUpgradePolicyLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Cluster ID this upgrade policy for control plane is defined for. */
      cluster_id?: string;
      /**
       * Format: date-time
       * @description Timestamp for creation of resource.
       */
      creation_timestamp?: string;
      /** @description Indicates if minor version upgrades are allowed for automatic upgrades (for manual it's always allowed). */
      enable_minor_version_upgrades?: boolean;
      /**
       * Format: date-time
       * @description Timestamp for last update that happened to resource.
       */
      last_update_timestamp?: string;
      /**
       * Format: date-time
       * @description Next time the upgrade should run.
       */
      next_run?: string;
      /** @description Schedule cron expression that defines automatic upgrade scheduling. */
      schedule?: string;
      /** @description Schedule type of the control plane upgrade. */
      schedule_type?: components['schemas']['ScheduleType'];
      /** @description State of the upgrade policy for the hosted control plane. */
      state?: components['schemas']['UpgradePolicyState'];
      /** @description Upgrade type of the control plane. */
      upgrade_type?: components['schemas']['UpgradeType'];
      /** @description Version is the desired upgrade version. */
      version?: string;
    };
    /** @description Contains the necessary attributes to allow each operator to access the necessary AWS resources */
    CredentialRequest: {
      /** @description Name of the credentials secret used to access cloud resources */
      name?: string;
      /** @description Namespace where the credentials secret lives in the cluster */
      namespace?: string;
      /** @description List of policy permissions needed to access cloud resources */
      policy_permissions?: string[];
      /** @description Service account name to use when authenticating */
      service_account?: string;
    };
    /** @description DeleteProtection configuration. */
    DeleteProtection: {
      /** @description Boolean flag indicating if the cluster should be be using _DeleteProtection_.
       *
       *     By default this is `false`.
       *
       *     To enable it a SREP needs to patch the value through OCM API */
      enabled?: boolean;
    };
    /** @enum {string} */
    DetectionType: DetectionType;
    /**
     * @description Which Ec2MetadataHttpTokens to use for metadata service interaction options for EC2 instances
     * @enum {string}
     */
    Ec2MetadataHttpTokens: Ec2MetadataHttpTokens;
    /** @description Description of a cloud provider encryption key. */
    EncryptionKey: {
      /** @description Indicates the type of this object. Will be 'EncryptionKey' if this is a complete object or 'EncryptionKeyLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Name of the encryption key. */
      name?: string;
    };
    /** @description Description of an environment */
    Environment: {
      /** @description the backplane url for the environment */
      backplane_url?: string;
      /**
       * Format: date-time
       * @description last time that the worker checked for limited support clusters
       */
      last_limited_support_check?: string;
      /**
       * Format: date-time
       * @description last time that the worker checked for available upgrades
       */
      last_upgrade_available_check?: string;
      /** @description environment name */
      name?: string;
    };
    /** @description Representation of a trackable event. */
    Event: {
      /** @description Body of the event to track the details of the tracking event as Key value pair */
      body?: {
        [key: string]: string;
      };
      /** @description Key of the event to be tracked. This key should start with an
       *     uppercase letter followed by alphanumeric characters or
       *     underscores. The entire key needs to be smaller than 64 characters. */
      key?: string;
    };
    /** @description Representation of an external authentication provider. */
    ExternalAuth: {
      /** @description Indicates the type of this object. Will be 'ExternalAuth' if this is a complete object or 'ExternalAuthLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description The rules on how to transform information from an ID token into a cluster identity. */
      claim?: components['schemas']['ExternalAuthClaim'];
      /** @description The list of the platform's clients that need to request tokens from the issuer. */
      clients?: components['schemas']['ExternalAuthClientConfig'][];
      /** @description The issuer describes the attributes of the OIDC token issuer. */
      issuer?: components['schemas']['TokenIssuer'];
      /** @description The status describes the current state of the external authentication provider.
       *     This is read-only. */
      status?: components['schemas']['ExternalAuthStatus'];
    };
    /** @description The claims and validation rules used in the configuration of the external authentication. */
    ExternalAuthClaim: {
      /** @description Mapping describes rules on how to transform information from an ID token into a cluster identity. */
      mappings?: components['schemas']['TokenClaimMappings'];
      /** @description ValidationRules are rules that are applied to validate token claims to authenticate users. */
      validation_rules?: components['schemas']['TokenClaimValidationRule'][];
    };
    /** @description ExternalAuthClientConfig contains configuration for the platform's clients that
     *     need to request tokens from the issuer. */
    ExternalAuthClientConfig: {
      /** @description The identifier of the OIDC client from the OIDC provider.
       *     This is required.
       *     Must be at least one character length. */
      id?: string;
      /** @description The component that is supposed to consume this client configuration. */
      component?: components['schemas']['ClientComponent'];
      /** @description ExtraScopes is an optional set of scopes to request tokens with. */
      extra_scopes?: string[];
      /** @description The secret of the OIDC client from the OIDC provider.
       *     The client is considered 'public' if no secret is specified. Otherwise, it is considered
       *     as a 'confidential' client.
       *     This can only be used for an external authentication provider belonging to a ROSA HCP cluster. */
      secret?: string;
      /** @description Determines the OIDC provider client type.
       *
       *     This is required to be defined for clients of an external authentication provider belonging to an ARO-HCP cluster.
       *
       *     For clients belonging to a ROSA HCP cluster, this is read-only. The value of this property will be determined by the
       *     'secret' property in the client configuration.
       *        - If the 'secret' property is set, the type of the client is 'confidential.
       *        - If the 'secret' property is not set, the type of the client is 'public. */
      type?: components['schemas']['ExternalAuthClientType'];
    };
    /**
     * @description Representation of the possible values of an external authentication client's type
     * @enum {string}
     */
    ExternalAuthClientType: ExternalAuthClientType;
    /** @description Represents an external authentication configuration */
    ExternalAuthConfig: {
      /** @description Indicates the type of this object. Will be 'ExternalAuthConfig' if this is a complete object or 'ExternalAuthConfigLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Boolean flag indicating if the cluster should use an external authentication configuration for ROSA HCP clusters.
       *
       *     By default this is false.
       *
       *     To enable it the cluster needs to be ROSA HCP cluster and the organization of the user needs
       *     to have the `external-authentication` feature toggle enabled.
       *
       *     For ARO HCP clusters, use the "State" property to enable/disable this feature instead. */
      enabled?: boolean;
      /** @description A list of external authentication providers configured for the cluster.
       *
       *     Only one external authentication provider can be configured. */
      external_auths?: components['schemas']['ExternalAuth'][];
      /** @description Controls whether the cluster uses an external authentication configuration for ARO HCP clusters.
       *
       *     For ARO HCP clusters, this will be "enabled" by default and cannot be set to "disabled".
       *
       *     FOR ROSA HCP clusters, use the "Enabled" boolean flag to enable/disable this feature instead. */
      state?: components['schemas']['ExternalAuthConfigState'];
    };
    /**
     * @description Representation of the possible values for the state field of an external authentication configuration
     * @enum {string}
     */
    ExternalAuthConfigState: ExternalAuthConfigState;
    /** @description Representation of the state of an external authentication provider. */
    ExternalAuthState: {
      /**
       * Format: date-time
       * @description The date and time when the external authentication provider state was last updated.
       */
      last_updated_timestamp?: string;
      /** @description A string value representing the external authentication provider's current state. */
      value?: string;
    };
    /** @description Representation of the status of an external authentication provider. */
    ExternalAuthStatus: {
      /** @description A descriptive message providing additional context about the current
       *     state of the external authentication provider. */
      message?: string;
      /** @description The current state of the external authentication provider. */
      state?: components['schemas']['ExternalAuthState'];
    };
    /** @description Representation of cluster external configuration. */
    ExternalConfiguration: {
      /** @description list of labels externally configured on the clusterdeployment. */
      labels?: components['schemas']['Label'][];
      /** @description list of manifest externally configured for a hosted cluster. */
      manifests?: components['schemas']['Manifest'][];
      /** @description list of syncsets externally configured on the cluster. */
      syncsets?: components['schemas']['Syncset'][];
    };
    /** @description Set of predefined properties of a cluster. For example, a _huge_ flavour can be a cluster
     *     with 10 infra nodes and 1000 compute nodes. */
    Flavour: {
      /** @description Indicates the type of this object. Will be 'Flavour' if this is a complete object or 'FlavourLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Default _Amazon Web Services_ settings of the cluster. */
      aws?: components['schemas']['AWSFlavour'];
      /** @description Default _Google Cloud Platform_ settings of the cluster. */
      gcp?: components['schemas']['GCPFlavour'];
      /** @description Human friendly identifier of the cluster, for example `4`.
       *
       *     NOTE: Currently for all flavours the `id` and `name` attributes have exactly the
       *     same values. */
      name?: string;
      /** @description Default network settings of the cluster.
       *
       *     These can be overridden specifying in the cluster itself a different set of settings. */
      network?: components['schemas']['Network'];
      /** @description Number of nodes that will be used by default when creating a cluster that uses
       *     this flavour.
       *
       *     These can be overridden specifying in the cluster itself a different number of nodes. */
      nodes?: components['schemas']['FlavourNodes'];
    };
    /** @description Counts of different classes of nodes inside a flavour. */
    FlavourNodes: {
      /**
       * Format: int32
       * @description Number of master nodes of the cluster.
       */
      master?: number;
    };
    /** @description Google cloud platform authentication method of a cluster. */
    GcpAuthentication: {
      /** @description Self link */
      href?: string;
      /** @description Unique identifier of the object */
      id?: string;
      /** @description Indicates the type of this object */
      kind?: string;
    };
    /** @description Google cloud platform private service connect configuration of a cluster. */
    GcpPrivateServiceConnect: {
      /** @description The name of the subnet where the PSC service attachment is created */
      service_attachment_subnet?: string;
    };
    /** @description Google cloud platform security settings of a cluster. */
    GcpSecurity: {
      /** @description Determines if Shielded VM feature "Secure Boot" should be set for the nodes of the cluster. */
      secure_boot?: boolean;
    };
    /** @description Details for `github` identity providers. */
    GithubIdentityProvider: {
      /** @description Optional trusted certificate authority bundle to use when making requests tot he server. */
      ca?: string;
      /** @description Client identifier of a registered _GitHub_ OAuth application. */
      client_id?: string;
      /** @description Client secret of a registered _GitHub_ OAuth application. */
      client_secret?: string;
      /** @description For _GitHub Enterprise_ you must provide the host name of your instance, such as
       *     `example.com`. This value must match the _GitHub Enterprise_ host name value in the
       *     `/setup/settings` file and cannot include a port number.
       *
       *     For plain _GitHub_ omit this parameter. */
      hostname?: string;
      /** @description Optional list of organizations. Cannot be used in combination with the Teams field. */
      organizations?: string[];
      /** @description Optional list of teams. Cannot be used in combination with the Organizations field. */
      teams?: string[];
    };
    /** @description Details for `gitlab` identity providers. */
    GitlabIdentityProvider: {
      /** @description Optional trusted certificate authority bundle to use when making requests tot he server. */
      ca?: string;
      /** @description URL of the _GitLab_ instance. */
      url?: string;
      /** @description Client identifier of a registered _GitLab_ OAuth application. */
      client_id?: string;
      /** @description Client secret issued by _GitLab_. */
      client_secret?: string;
    };
    /** @description Details for `google` identity providers. */
    GoogleIdentityProvider: {
      /** @description Client identifier of a registered _Google_ project. */
      client_id?: string;
      /** @description Client secret issued by _Google_. */
      client_secret?: string;
      /** @description Optional hosted domain to restrict sign-in accounts to. */
      hosted_domain?: string;
    };
    /** @description Representation of a group of users. */
    Group: {
      /** @description Indicates the type of this object. Will be 'Group' if this is a complete object or 'GroupLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description List of users of the group. */
      users?: components['schemas']['User'][];
    };
    GroupsClaim: {
      /** @description The claim used in the token. */
      claim?: string;
      /** @description A prefix contatenated in the claim (Optional). */
      prefix?: string;
    };
    /** @description Hypershift configuration. */
    Hypershift: {
      /** @description Boolean flag indicating if the cluster should be creating using _Hypershift_.
       *
       *     By default this is `false`.
       *
       *     To enable it the cluster needs to be ROSA cluster and the organization of the user needs
       *     to have the `hypershift` capability enabled. */
      enabled?: boolean;
    };
    /** @description Hypershift configuration. */
    HypershiftConfig: {
      /** @description Contains the name of the hcp namespace for this Hypershift cluster.
       *     Empty for non Hypershift clusters. */
      hcp_namespace?: string;
      /** @description Boolean flag indicating if the cluster should be creating using _Hypershift_.
       *
       *     By default this is `false`.
       *
       *     To enable it the cluster needs to be ROSA cluster and the organization of the user needs
       *     to have the `hypershift` capability enabled. */
      enabled?: boolean;
      /** @description Contains the name of the current management cluster for this Hypershift cluster.
       *     Empty for non Hypershift clusters. */
      management_cluster?: string;
    };
    /** @description Representation of an identity provider. */
    IdentityProvider: {
      /** @description Indicates the type of this object. Will be 'IdentityProvider' if this is a complete object or 'IdentityProviderLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Details for `ldap` identity providers. */
      ldap?: components['schemas']['LDAPIdentityProvider'];
      /** @description When `true` unauthenticated token requests from non-web clients (like the CLI) are sent a
       *     `WWW-Authenticate` challenge header for this provider. */
      challenge?: boolean;
      /** @description Details for `github` identity providers. */
      github?: components['schemas']['GithubIdentityProvider'];
      /** @description Details for `gitlab` identity providers. */
      gitlab?: components['schemas']['GitlabIdentityProvider'];
      /** @description Details for `google` identity providers. */
      google?: components['schemas']['GoogleIdentityProvider'];
      /** @description Details for `htpasswd` identity providers. */
      htpasswd?: components['schemas']['HTPasswdIdentityProvider'];
      /** @description When `true` unauthenticated token requests from web clients (like the web console) are
       *     redirected to the authorize URL to log in. */
      login?: boolean;
      /** @description Controls how mappings are established between this provider's identities and user
       *     objects. */
      mapping_method?: components['schemas']['IdentityProviderMappingMethod'];
      /** @description The name of the identity provider. */
      name?: string;
      /** @description Details for `openid` identity providers. */
      open_id?: components['schemas']['OpenIDIdentityProvider'];
      /** @description Type of identity provider. The rest of the attributes will be populated according to this
       *     value. For example, if the type is `github` then only the `github` attribute will be
       *     populated. */
      type?: components['schemas']['IdentityProviderType'];
    };
    /**
     * @description Controls how mappings are established between provider identities and user objects.
     * @enum {string}
     */
    IdentityProviderMappingMethod: IdentityProviderMappingMethod;
    /**
     * @description Type of identity provider.
     * @enum {string}
     */
    IdentityProviderType: IdentityProviderType;
    /** @description ImageMirror represents a container image mirror configuration for a cluster.
     *     This enables Day 2 image mirroring configuration for ROSA HCP clusters using
     *     HyperShift's native imageContentSources mechanism. */
    ImageMirror: {
      /** @description Indicates the type of this object. Will be 'ImageMirror' if this is a complete object or 'ImageMirrorLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: date-time
       * @description CreationTimestamp indicates when the image mirror was created.
       */
      creation_timestamp?: string;
      /**
       * Format: date-time
       * @description LastUpdateTimestamp indicates when the image mirror was last updated.
       */
      last_update_timestamp?: string;
      /** @description Mirrors is the list of mirror registries that will serve content for the source.
       *     Mirrors array cannot be empty (must contain at least one mirror registry).
       *     Each mirror registry URL must conform to OpenShift's ImageDigestMirrorSet format specifications. */
      mirrors?: string[];
      /** @description Source is the source registry that will be mirrored.
       *     Source registry must be unique per cluster and is immutable after creation.
       *     Source is used to identify mirror entries in HostedCluster imageContentSources. */
      source?: string;
      /** @description Type specifies the mirror type, currently only "digest" is supported. */
      type?: string;
    };
    /** @description ImageOverrides holds the lists of available images per cloud provider. */
    ImageOverrides: {
      /** @description Indicates the type of this object. Will be 'ImageOverrides' if this is a complete object or 'ImageOverridesLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      aws?: components['schemas']['AMIOverride'][];
      gcp?: components['schemas']['GCPImageOverride'][];
    };
    /** @description Representation of check running before the cluster is provisioned. */
    InflightCheck: {
      /** @description Indicates the type of this object. Will be 'InflightCheck' if this is a complete object or 'InflightCheckLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Details regarding the state of the inflight check. */
      details?: Record<string, never>;
      /**
       * Format: date-time
       * @description The time the check finished running.
       */
      ended_at?: string;
      /** @description The name of the inflight check. */
      name?: string;
      /**
       * Format: int32
       * @description The number of times the inflight check restarted.
       */
      restarts?: number;
      /**
       * Format: date-time
       * @description The time the check started running.
       */
      started_at?: string;
      /** @description State of the inflight check. */
      state?: components['schemas']['InflightCheckState'];
    };
    /**
     * @description State of an inflight check.
     * @enum {string}
     */
    InflightCheckState: InflightCheckState;
    /** @description Representation of an ingress. */
    Ingress: {
      /** @description Indicates the type of this object. Will be 'Ingress' if this is a complete object or 'IngressLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description DNS Name of the ingress. */
      dns_name?: string;
      /** @description Cluster routes hostname. */
      cluster_routes_hostname?: string;
      /** @description Cluster routes TLS Secret reference. */
      cluster_routes_tls_secret_ref?: string;
      /** @description Component Routes settings. */
      component_routes?: {
        [key: string]: components['schemas']['ComponentRoute'];
      };
      /** @description Indicates if this is the default ingress. */
      default?: boolean;
      /** @description A set of excluded namespaces for the ingress. */
      excluded_namespaces?: string[];
      /** @description Listening method of the ingress */
      listening?: components['schemas']['ListeningMethod'];
      /** @description Load Balancer type of the ingress */
      load_balancer_type?: components['schemas']['LoadBalancerFlavor'];
      /** @description Namespace Ownership Policy for the ingress. */
      route_namespace_ownership_policy?: components['schemas']['NamespaceOwnershipPolicy'];
      /** @description A set of labels for the ingress.  */
      route_selectors?: {
        [key: string]: string;
      };
      /** @description Wildcard policy for the ingress. */
      route_wildcard_policy?: components['schemas']['WildcardPolicy'];
    };
    /** @description Contains the necessary attributes to support role-based authentication on AWS. */
    InstanceIAMRoles: {
      /** @description The IAM role ARN that will be attached to master instances */
      master_role_arn?: string;
      /** @description The IAM role ARN that will be attached to worker instances */
      worker_role_arn?: string;
    };
    /** @description Description of a cloud provider key ring. */
    KeyRing: {
      /** @description Indicates the type of this object. Will be 'KeyRing' if this is a complete object or 'KeyRingLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Name of the key ring. */
      name?: string;
    };
    /** @description OCM representation of KubeletConfig, exposing the fields of Kubernetes
     *     KubeletConfig that can be managed by users */
    KubeletConfig: {
      /** @description Indicates the type of this object. Will be 'KubeletConfig' if this is a complete object or 'KubeletConfigLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Allows the user to specify the name to be used to identify this KubeletConfig.
       *     Optional. A name will be generated if not provided. */
      name?: string;
      /**
       * Format: int32
       * @description Allows the user to specify the podPidsLimit to be applied via KubeletConfig.
       *     Useful if workloads have greater PIDs limit requirements than the OCP default.
       */
      pod_pids_limit?: number;
    };
    /** @description Representation of a label in clusterdeployment. */
    Label: {
      /** @description Indicates the type of this object. Will be 'Label' if this is a complete object or 'LabelLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description the key of the label */
      key?: string;
      /** @description the value to set in the label */
      value?: string;
    };
    /** @description A reason that a cluster is in limited support. */
    LimitedSupportReason: {
      /** @description Indicates the type of this object. Will be 'LimitedSupportReason' if this is a complete object or 'LimitedSupportReasonLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: date-time
       * @description The time the reason was detected.
       */
      creation_timestamp?: string;
      /** @description URL with a link to a detailed description of the reason. */
      details?: string;
      /** @description Indicates if the reason was detected automatically or manually.
       *     When creating a new reason this field should be empty or "manual". */
      detection_type?: components['schemas']['DetectionType'];
      /** @description Indicates if the override is enabled */
      override?: components['schemas']['LimitedSupportReasonOverride'];
      /** @description Summary of the reason. */
      summary?: string;
      /** @description Optional link to a template with summary and details. */
      template?: components['schemas']['LimitedSupportReasonTemplate'];
    };
    /** @description Representation of the limited support reason override. */
    LimitedSupportReasonOverride: {
      /** @description Indicates the type of this object. Will be 'LimitedSupportReasonOverride' if this is a complete object or 'LimitedSupportReasonOverrideLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Indicates if the override is enabled */
      enabled?: boolean;
    };
    /** @description A template for cluster limited support reason. */
    LimitedSupportReasonTemplate: {
      /** @description Indicates the type of this object. Will be 'LimitedSupportReasonTemplate' if this is a complete object or 'LimitedSupportReasonTemplateLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description A detailed description of the reason. */
      details?: string;
      /** @description Summary of the reason. */
      summary?: string;
    };
    /**
     * @description Cluster components listening method.
     * @enum {string}
     */
    ListeningMethod: ListeningMethod;
    /**
     * @description Type of load balancer for AWS cloud provider parameters.
     * @enum {string}
     */
    LoadBalancerFlavor: LoadBalancerFlavor;
    /** @description Log of the cluster. */
    Log: {
      /** @description Indicates the type of this object. Will be 'Log' if this is a complete object or 'LogLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Content of the log. */
      content?: string;
    };
    /** @description Representation of a machine pool in a cluster. */
    MachinePool: {
      /** @description Indicates the type of this object. Will be 'MachinePool' if this is a complete object or 'MachinePoolLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description AWS specific parameters (Optional). */
      aws?: components['schemas']['AWSMachinePool'];
      /** @description GCP specific parameters (Optional). */
      gcp?: components['schemas']['GCPMachinePool'];
      /** @description Details for auto-scaling the machine pool.
       *     Replicas and autoscaling cannot be used together. */
      autoscaling?: components['schemas']['MachinePoolAutoscaling'];
      /** @description The availability zones upon which the nodes are created. */
      availability_zones?: string[];
      /** @description The instance type of Nodes to create. */
      instance_type?: string;
      /** @description The labels set on the Nodes created. */
      labels?: {
        [key: string]: string;
      };
      /**
       * Format: int32
       * @description The number of Machines (and Nodes) to create.
       *     Replicas and autoscaling cannot be used together.
       */
      replicas?: number;
      /** @description The machine root volume capabilities. */
      root_volume?: components['schemas']['RootVolume'];
      /** @description List of security groups to be applied to MachinePool (Optional) */
      security_group_filters?: components['schemas']['MachinePoolSecurityGroupFilter'][];
      /** @description The subnets upon which the nodes are created. */
      subnets?: string[];
      /** @description The taints set on the Nodes created. */
      taints?: components['schemas']['Taint'][];
    };
    /** @description Representation of a autoscaling in a machine pool. */
    MachinePoolAutoscaling: {
      /** @description Indicates the type of this object. Will be 'MachinePoolAutoscaling' if this is a complete object or 'MachinePoolAutoscalingLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: int32
       * @description The maximum number of replicas for the machine pool.
       */
      max_replicas?: number;
      /**
       * Format: int32
       * @description The minimum number of replicas for the machine pool.
       */
      min_replicas?: number;
    };
    /** @description Security Group Filter object, containing name of the filter tag and value of the filter tag */
    MachinePoolSecurityGroupFilter: {
      name?: string;
      value?: string;
    };
    /** @description Machine type. */
    MachineType: {
      /** @description Indicates the type of this object. Will be 'MachineType' if this is a complete object or 'MachineTypeLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description 'true' if the instance type is supported only for CCS clusters, 'false' otherwise. */
      ccs_only?: boolean;
      /** @description The amount of cpu's of the machine type. */
      cpu?: components['schemas']['Value'];
      /** @description The architecture of the machine type. */
      architecture?: components['schemas']['ProcessorType'];
      /** @description The category which the machine type is suitable for. */
      category?: components['schemas']['MachineTypeCategory'];
      /** @description Link to the cloud provider that the machine type belongs to. */
      cloud_provider?: components['schemas']['CloudProvider'];
      /** @description Generic name for quota purposes, for example `highmem-4`.
       *     Cloud provider agnostic - many values are shared between "similar"
       *     machine types on different providers.
       *     Corresponds to `resource_name` values in "compute.node"  quota cost data. */
      generic_name?: string;
      /** @description The amount of memory of the machine type. */
      memory?: components['schemas']['Value'];
      /** @description Human friendly identifier of the machine type, for example `r5.xlarge - Memory Optimized`. */
      name?: string;
      /** @description The size of the machine type. */
      size?: components['schemas']['MachineTypeSize'];
    };
    /**
     * @description Machine type category.
     * @enum {string}
     */
    MachineTypeCategory: MachineTypeCategory;
    /**
     * @description Machine type size.
     * @enum {string}
     */
    MachineTypeSize: MachineTypeSize;
    /** @description Contains the necessary attributes to support role-based authentication on AWS. */
    ManagedService: {
      /** @description Indicates whether the cluster belongs to a managed service
       *     This should only be set by the "Managed Service" service.
       *     clusters with this set can only be modified by the "Managed Service" service. */
      enabled?: boolean;
    };
    /** @description Representation of a manifestwork. */
    Manifest: {
      /** @description Indicates the type of this object. Will be 'Manifest' if this is a complete object or 'ManifestLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: date-time
       * @description Date and time when the manifest got created in OCM database.
       */
      creation_timestamp?: string;
      /** @description Transient value to represent the underlying live resource. */
      live_resource?: Record<string, never>;
      /** @description Spec of Manifest Work object from open cluster management
       *     For more info please check https://open-cluster-management.io/concepts/manifestwork. */
      spec?: Record<string, never>;
      /**
       * Format: date-time
       * @description Date and time when the manifest got updated in OCM database.
       */
      updated_timestamp?: string;
      /** @description List of k8s objects to deploy on a hosted cluster. */
      workloads?: Record<string, never>[];
    };
    /**
     * @description Market type for AWS Capacity Reservations.
     * @enum {string}
     */
    MarketType: MarketType;
    /**
     * @description Type of Namespace Ownership Policy.
     * @enum {string}
     */
    NamespaceOwnershipPolicy: NamespaceOwnershipPolicy;
    /** @description Network configuration of a cluster. */
    Network: {
      /**
       * Format: int32
       * @description Network host prefix which is defaulted to `23` if not specified.
       */
      host_prefix?: number;
      /** @description IP address block from which to assign machine IP addresses, for example `10.0.0.0/16`. */
      machine_cidr?: string;
      /** @description IP address block from which to assign pod IP addresses, for example `10.128.0.0/14`. */
      pod_cidr?: string;
      /** @description IP address block from which to assign service IP addresses, for example `172.30.0.0/16`. */
      service_cidr?: string;
      /** @description The main controller responsible for rendering the core networking components. */
      type?: string;
    };
    NetworkVerification: {
      /** @description Cloud provider data to execute the network verification. */
      cloud_provider_data?: components['schemas']['CloudProviderData'];
      /** @description Cluster ID needed to execute the network verification. */
      cluster_id?: string;
      /** @description Details about each subnet network verification. */
      items?: components['schemas']['SubnetNetworkVerification'][];
      /** @description Platform needed to execute the network verification. */
      platform?: components['schemas']['Platform'];
      /**
       * Format: int32
       * @description Amount of network verifier executions started.
       */
      total?: number;
    };
    /** @description Provides information about a node from specific type in the cluster. */
    NodeInfo: {
      /**
       * Format: int32
       * @description The amount of the nodes from this type.
       */
      amount?: number;
      /** @description The Node type. */
      type?: components['schemas']['NodeType'];
    };
    /** @description Representation of a node pool in a cluster. */
    NodePool: {
      /** @description Indicates the type of this object. Will be 'NodePool' if this is a complete object or 'NodePoolLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description AWS specific parameters (Optional). */
      aws_node_pool?: components['schemas']['AWSNodePool'];
      /** @description Specifies whether health checks should be enabled for machines in the NodePool. */
      auto_repair?: boolean;
      /** @description Details for auto-scaling the machine pool.
       *     Replicas and autoscaling cannot be used together. */
      autoscaling?: components['schemas']['NodePoolAutoscaling'];
      /** @description The availability zone upon which the node is created. */
      availability_zone?: string;
      /** @description Azure specific parameters. */
      azure_node_pool?: components['schemas']['AzureNodePool'];
      /** @description The names of the KubeletConfigs for this node pool. */
      kubelet_configs?: string[];
      /** @description The labels set on the Nodes created. */
      labels?: {
        [key: string]: string;
      };
      /** @description Management parameters (Optional). */
      management_upgrade?: components['schemas']['NodePoolManagementUpgrade'];
      /** @description Time to wait for a NodePool to drain when it is upgraded or replaced before it is forcibly removed. */
      node_drain_grace_period?: components['schemas']['Value'];
      /**
       * Format: int32
       * @description The number of Machines (and Nodes) to create.
       *     Replicas and autoscaling cannot be used together.
       */
      replicas?: number;
      /** @description NodePool status. */
      status?: components['schemas']['NodePoolStatus'];
      /** @description The subnet upon which the nodes are created. */
      subnet?: string;
      /** @description The taints set on the Nodes created. */
      taints?: components['schemas']['Taint'][];
      /** @description The names of the tuning configs for this node pool. */
      tuning_configs?: string[];
      /** @description Version of the node pool. */
      version?: components['schemas']['Version'];
    };
    /** @description Representation of a autoscaling in a node pool. */
    NodePoolAutoscaling: {
      /** @description Indicates the type of this object. Will be 'NodePoolAutoscaling' if this is a complete object or 'NodePoolAutoscalingLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: int32
       * @description The maximum number of replicas for the node pool.
       */
      max_replica?: number;
      /**
       * Format: int32
       * @description The minimum number of replicas for the node pool.
       */
      min_replica?: number;
    };
    /** @description Representation of node pool management. */
    NodePoolManagementUpgrade: {
      /** @description Indicates the type of this object. Will be 'NodePoolManagementUpgrade' if this is a complete object or 'NodePoolManagementUpgradeLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Maximum number of nodes in the NodePool of a ROSA HCP cluster that can be scheduled above the desired number of nodes during the upgrade. */
      max_surge?: string;
      /** @description Maximum number of nodes in the NodePool of a ROSA HCP cluster that can be unavailable during the upgrade. */
      max_unavailable?: string;
      /** @description Type of strategy for handling upgrades. */
      type?: string;
    };
    /** @description Representation of the status of a node pool. */
    NodePoolState: {
      /** @description Indicates the type of this object. Will be 'NodePoolState' if this is a complete object or 'NodePoolStateLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: date-time
       * @description The current number of replicas for the node pool.
       */
      last_updated_timestamp?: string;
      /** @description The current state of the node pool */
      value?: string;
    };
    /** @description Representation of the status of a node pool. */
    NodePoolStatus: {
      /** @description Indicates the type of this object. Will be 'NodePoolStatus' if this is a complete object or 'NodePoolStatusLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: int32
       * @description The current number of replicas for the node pool.
       */
      current_replicas?: number;
      /** @description Adds additional information about the NodePool status when the node pool doesn't reach the desired replicas. */
      message?: string;
      /** @description The current state of the node pool */
      state?: components['schemas']['NodePoolState'];
    };
    /** @description Representation of an upgrade policy that can be set for a node pool. */
    NodePoolUpgradePolicy: {
      /** @description Indicates the type of this object. Will be 'NodePoolUpgradePolicy' if this is a complete object or 'NodePoolUpgradePolicyLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Cluster ID this upgrade policy for node pool is defined for. */
      cluster_id?: string;
      /**
       * Format: date-time
       * @description Timestamp for creation of resource.
       */
      creation_timestamp?: string;
      /** @description Indicates if minor version upgrades are allowed for automatic upgrades (for manual it's always allowed). */
      enable_minor_version_upgrades?: boolean;
      /**
       * Format: date-time
       * @description Timestamp for last update that happened to resource.
       */
      last_update_timestamp?: string;
      /**
       * Format: date-time
       * @description Next time the upgrade should run.
       */
      next_run?: string;
      /** @description Node Pool ID this upgrade policy is defined for. */
      node_pool_id?: string;
      /** @description Schedule cron expression that defines automatic upgrade scheduling. */
      schedule?: string;
      /** @description Schedule type of the upgrade. */
      schedule_type?: components['schemas']['ScheduleType'];
      /** @description State of the upgrade policy for the node pool. */
      state?: components['schemas']['UpgradePolicyState'];
      /** @description Upgrade type of the node pool. */
      upgrade_type?: components['schemas']['UpgradeType'];
      /** @description Version is the desired upgrade version. */
      version?: string;
    };
    /**
     * @description Type of node received via telemetry.
     * @enum {string}
     */
    NodeType: NodeType;
    /** @description Provides information about the nodes in the cluster. */
    NodesInfo: {
      nodes?: components['schemas']['NodeInfo'][];
    };
    /** @description Contains the necessary attributes to support oidc configuration hosting under Red Hat or registering a Customer's byo oidc config. */
    OidcConfig: {
      /** @description HREF for the oidc config, filled in response. */
      href?: string;
      /** @description ID for the oidc config, filled in response. */
      id?: string;
      /**
       * Format: date-time
       * @description Creation timestamp, filled in response.
       */
      creation_timestamp?: string;
      /** @description ARN of the AWS role to assume when installing the cluster as to reveal the secret, supplied in request. It is only to be used in Unmanaged Oidc Config. */
      installer_role_arn?: string;
      /** @description Issuer URL, filled in response when Managed and supplied in Unmanaged. */
      issuer_url?: string;
      /**
       * Format: date-time
       * @description Last update timestamp, filled when patching a valid attribute of this oidc config.
       */
      last_update_timestamp?: string;
      /**
       * Format: date-time
       * @description Last used timestamp, filled by the latest cluster that used this oidc config.
       */
      last_used_timestamp?: string;
      /** @description Indicates whether it is Managed or Unmanaged (Customer hosted). */
      managed?: boolean;
      /** @description Organization ID, filled in response respecting token provided. */
      organization_id?: string;
      /** @description Indicates whether the Oidc Config can be reused. */
      reusable?: boolean;
      /** @description Secrets Manager ARN for the OIDC private key, supplied in request. It is only to be used in Unmanaged Oidc Config. */
      secret_arn?: string;
    };
    /** @description Contains the necessary attributes to support oidc configuration thumbprint operations such as fetching/creation of a thumbprint */
    OidcThumbprint: {
      /** @description HREF for the oidc config thumbprint, filled in response. */
      href?: string;
      /** @description ClusterId is the for the cluster used, filled in response. */
      cluster_id?: string;
      /** @description Kind is the resource type, filled in response. */
      kind?: string;
      /** @description OidcConfigId is the ID for the oidc config used, filled in response. */
      oidc_config_id?: string;
      /** @description Thumbprint is the thumbprint itself, filled in response. */
      thumbprint?: string;
    };
    /** @description Contains the necessary attributes to fetch an OIDC Configuration thumbprint */
    OidcThumbprintInput: {
      /** @description ClusterId is the for the cluster used, exclusive from OidcConfigId. */
      cluster_id?: string;
      /** @description OidcConfigId is the ID for the oidc config used, exclusive from ClusterId. */
      oidc_config_id?: string;
    };
    /** @description _OpenID_ identity provider claims. */
    OpenIDClaims: {
      /** @description List of claims to use as the mail address. */
      email?: string[];
      /** @description List of claims to use as the group name. */
      groups?: string[];
      /** @description List of claims to use as the display name. */
      name?: string[];
      /** @description List of claims to use as the preferred user name when provisioning a user. */
      preferred_username?: string[];
    };
    /** @description Details for `openid` identity providers. */
    OpenIDIdentityProvider: {
      /** @description Certificate bunde to use to validate server certificates for the configured URL. */
      ca?: string;
      /** @description Claims used to configure the provider. */
      claims?: components['schemas']['OpenIDClaims'];
      /** @description Identifier of a client registered with the _OpenID_ provider. */
      client_id?: string;
      /** @description Client secret. */
      client_secret?: string;
      /** @description Optional map of extra parameters to add to the authorization token request. */
      extra_authorize_parameters?: {
        [key: string]: string;
      };
      /** @description Optional list of scopes to request, in addition to the `openid` scope, during the
       *     authorization token request. */
      extra_scopes?: string[];
      /** @description The URL that the OpenID Provider asserts as the Issuer Identifier */
      issuer?: string;
    };
    /** @description Contains the necessary attributes to allow each operator to access the necessary AWS resources */
    OperatorIAMRole: {
      /** @description Randomly-generated ID to identify the operator role */
      id?: string;
      /** @description Name of the credentials secret used to access cloud resources */
      name?: string;
      /** @description Namespace where the credentials secret lives in the cluster */
      namespace?: string;
      /** @description Role to assume when accessing AWS resources */
      role_arn?: string;
      /** @description Service account name to use when authenticating */
      service_account?: string;
    };
    /** @description Definition of an organization link. */
    OrganizationLink: {
      /** @description HREF for the Organization, filled in response. */
      href?: string;
      /** @description The organization's ID. */
      id?: string;
    };
    /** @description Represents a pending delete entry for a specific cluster. */
    PendingDeleteCluster: {
      /** @description Indicates the type of this object. Will be 'PendingDeleteCluster' if this is a complete object or 'PendingDeleteClusterLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Flag indicating if the cluster deletion should be best-effort mode or not. */
      best_effort?: boolean;
      /** @description Cluster is the details of the cluster that is pending deletion. */
      cluster?: components['schemas']['Cluster'];
      /**
       * Format: date-time
       * @description Date and time when the cluster was initially created, using the
       *     format defined in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt).
       */
      creation_timestamp?: string;
    };
    /**
     * @description Representation of an platform type field.
     * @enum {string}
     */
    Platform: Platform;
    /** @description Manages the configuration for the Private Links. */
    PrivateLinkClusterConfiguration: {
      /** @description List of additional principals for the Private Link */
      principals?: components['schemas']['PrivateLinkPrincipal'][];
    };
    /** @description Manages the configuration for the Private Links. */
    PrivateLinkConfiguration: {
      /** @description List of additional principals for the Private Link */
      principals?: components['schemas']['PrivateLinkPrincipals'];
    };
    PrivateLinkPrincipal: {
      /** @description Indicates the type of this object. Will be 'PrivateLinkPrincipal' if this is a complete object or 'PrivateLinkPrincipalLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description ARN for a principal that is allowed for this Private Link. */
      principal?: string;
    };
    /** @description Contains a list of principals for the Private Link. */
    PrivateLinkPrincipals: {
      /** @description Indicates the type of this object. Will be 'PrivateLinkPrincipals' if this is a complete object or 'PrivateLinkPrincipalsLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description List of additional principals for the Private Link */
      principals?: components['schemas']['PrivateLinkPrincipal'][];
    };
    /**
     * @description Processor type category.
     * @enum {string}
     */
    ProcessorType: ProcessorType;
    /** @description Representation of an product that can be selected as a cluster type. */
    Product: {
      /** @description Indicates the type of this object. Will be 'Product' if this is a complete object or 'ProductLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Name of the product. */
      name?: string;
    };
    /** @description Representation of a product minimal version. */
    ProductMinimalVersion: {
      /** @description Indicates the type of this object. Will be 'ProductMinimalVersion' if this is a complete object or 'ProductMinimalVersionLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description The ROSA CLI minimal version. */
      rosa_cli?: string;
      /**
       * Format: date-time
       * @description The start date for this minimal version.
       */
      start_date?: string;
    };
    /** @description Representation of a product technology preview. */
    ProductTechnologyPreview: {
      /** @description Indicates the type of this object. Will be 'ProductTechnologyPreview' if this is a complete object or 'ProductTechnologyPreviewLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Message associated with this technology preview. */
      additional_text?: string;
      /**
       * Format: date-time
       * @description The end date for this technology preview.
       */
      end_date?: string;
      /**
       * Format: date-time
       * @description The start date for this technology preview.
       */
      start_date?: string;
    };
    /** @description Contains the properties of the provision shard, including AWS and GCP related configurations */
    ProvisionShard: {
      /** @description Indicates the type of this object. Will be 'ProvisionShard' if this is a complete object or 'ProvisionShardLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Contains the configuration for the AWS account operator. */
      aws_account_operator_config?: components['schemas']['ServerConfig'];
      /** @description Contains the AWS base domain. */
      aws_base_domain?: string;
      /** @description Contains the GCP base domain. */
      gcp_base_domain?: string;
      /** @description Contains the configuration for the GCP project operator. */
      gcp_project_operator?: components['schemas']['ServerConfig'];
      /** @description Contains the cloud provider name. */
      cloud_provider?: components['schemas']['CloudProvider'];
      /**
       * Format: date-time
       * @description Date and time when the provision shard was initially created, using the
       *     format defined in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt).
       */
      creation_timestamp?: string;
      /** @description Contains the configuration for Hive. */
      hive_config?: components['schemas']['ServerConfig'];
      /** @description Contains the configuration for Hypershift. */
      hypershift_config?: components['schemas']['ServerConfig'];
      /**
       * Format: date-time
       * @description Date and time when the provision shard was last updated, using the
       *     format defined in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt).
       */
      last_update_timestamp?: string;
      /** @description Contains the name of the management cluster for Hypershift clusters that are assigned to this shard.
       *     This field is populated by OCM, and must not be overwritten via API. */
      management_cluster?: string;
      /** @description Contains the cloud-provider region in which the provisioner spins up the cluster. */
      region?: components['schemas']['CloudRegion'];
      /** @description Status of the provision shard. Possible values: active/maintenance/offline. */
      status?: string;
    };
    /** @enum {string} */
    ProvisionShardTopology: ProvisionShardTopology;
    /** @description Proxy configuration of a cluster. */
    Proxy: {
      /** @description HTTPProxy is the URL of the proxy for HTTP requests. */
      http_proxy?: string;
      /** @description HTTPSProxy is the URL of the proxy for HTTPS requests. */
      https_proxy?: string;
      /** @description NoProxy is a comma-separated list of domains and CIDRs for which
       *     the proxy should not be used */
      no_proxy?: string;
    };
    /** @description RegistryAllowlist represents a single registry allowlist. */
    RegistryAllowlist: {
      /** @description Indicates the type of this object. Will be 'RegistryAllowlist' if this is a complete object or 'RegistryAllowlistLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description CloudProvider is the cloud provider for which this allowlist is valid. */
      cloud_provider?: components['schemas']['CloudProvider'];
      /**
       * Format: date-time
       * @description CreationTimestamp is the date and time when the allow list has been created.
       */
      creation_timestamp?: string;
      /** @description Registries is the list of registries contained in this Allowlist. */
      registries?: string[];
    };
    /** @description RegistryLocation contains a location of the registry specified by the registry domain
     *     name. The domain name might include wildcards, like '*' or '??'. */
    RegistryLocation: {
      /** @description domainName specifies a domain name for the registry
       *     In case the registry use non-standard (80 or 443) port, the port should be included
       *     in the domain name as well. */
      domain_name?: string;
      /** @description insecure indicates whether the registry is secure (https) or insecure (http)
       *     By default (if not specified) the registry is assumed as secure. */
      insecure?: boolean;
    };
    /** @description RegistrySources contains configuration that determines how the container runtime should treat individual
     *     registries when accessing images for builds and pods. For instance, whether or not to allow insecure access.
     *     It does not contain configuration for the internal cluster registry. */
    RegistrySources: {
      /** @description AllowedRegistries: registries for which image pull and push actions are allowed.
       *     To specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name.
       *     For example, *.example.com. You can specify an individual repository within a registry.
       *     For example: reg1.io/myrepo/myapp:latest. All other registries are blocked.
       *     Mutually exclusive with `BlockedRegistries` */
      allowed_registries?: string[];
      /** @description BlockedRegistries: registries for which image pull and push actions are denied.
       *     To specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name.
       *     For example, *.example.com. You can specify an individual repository within a registry.
       *     For example: reg1.io/myrepo/myapp:latest. All other registries are allowed.
       *     Mutually exclusive with `AllowedRegistries` */
      blocked_registries?: string[];
      /** @description InsecureRegistries are registries which do not have a valid TLS certificate or only support HTTP connections.
       *     To specify all subdomains, add the asterisk (*) wildcard character as a prefix to the domain name.
       *     For example, *.example.com. You can specify an individual repository within a registry.
       *     For example: reg1.io/myrepo/myapp:latest. */
      insecure_registries?: string[];
    };
    ReleaseImageDetails: {
      /** @description AvailableUpgrades is the list of versions this version can be upgraded to. */
      available_upgrades?: string[];
      /** @description ReleaseImage contains the URI of Openshift release image. */
      release_image?: string;
    };
    ReleaseImages: {
      /** @description Arm64 will contain the reference for the arm64 image which will be used for cluster deployments */
      arm64?: components['schemas']['ReleaseImageDetails'];
      /** @description Multi will contain the reference for the multi image which will be used for cluster deployments */
      multi?: components['schemas']['ReleaseImageDetails'];
    };
    ResourceRange: {
      /** Format: int32 */
      max?: number;
      /** Format: int32 */
      min?: number;
    };
    RolePolicy: {
      arn?: string;
      name?: string;
      type?: string;
    };
    RolePolicyBinding: {
      arn?: string;
      /** Format: date-time */
      creation_timestamp?: string;
      /** Format: date-time */
      last_update_timestamp?: string;
      name?: string;
      policies?: components['schemas']['RolePolicy'][];
      status?: components['schemas']['RolePolicyBindingStatus'];
      type?: string;
    };
    RolePolicyBindingStatus: {
      description?: string;
      value?: string;
    };
    /** @description Root volume capabilities. */
    RootVolume: {
      /** @description AWS volume specification */
      aws?: components['schemas']['AWSVolume'];
      /** @description GCP Volume specification */
      gcp?: components['schemas']['GCPVolume'];
    };
    /**
     * @description ScheduleType defines which type of scheduling should be used for the upgrade policy.
     * @enum {string}
     */
    ScheduleType: ScheduleType;
    /** @description Details for `SdnToOvn` cluster migrations. */
    SdnToOvnClusterMigration: {
      /** @description The IP address range to use for the internalJoinSubnet parameter of OVN-Kubernetes
       *     upon migration. */
      join_ipv4?: string;
      /** @description The IP address range to us for the internalMasqueradeSubnet parameter of OVN-Kubernetes
       *     upon migration. */
      masquerade_ipv4?: string;
      /** @description The IP address range to use for the internalTransSwitchSubnet parameter of OVN-Kubernetes
       *     upon migration. */
      transit_ipv4?: string;
    };
    /** @description AWS security group object */
    SecurityGroup: {
      /** @description The security group ID. */
      id?: string;
      /** @description Name of the security group according to its `Name` tag on AWS. */
      name?: string;
      /** @description If the resource is RH managed. */
      red_hat_managed?: boolean;
    };
    /** @description Representation of a server config */
    ServerConfig: {
      /** @description Indicates the type of this object. Will be 'ServerConfig' if this is a complete object or 'ServerConfigLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Config for AWS provision shards */
      aws_shard?: components['schemas']['AWSShard'];
      /** @description The kubeconfig of the server. */
      kubeconfig?: string;
      /** @description The URL of the server. */
      server?: string;
      /** @description The topology of a provision shard (Optional). */
      topology?: components['schemas']['ProvisionShardTopology'];
    };
    /** @description Representation of information from telemetry about a the socket capacity
     *     by node role and OS. */
    SocketTotalNodeRoleOSMetricNode: {
      /** @description Representation of the node role for a cluster. */
      node_roles?: string[];
      /** @description The operating system. */
      operating_system?: string;
      /**
       * Format: float
       * @description The total socket capacity of nodes with this set of roles and operating system.
       */
      socket_total?: number;
      /** Format: date-time */
      time?: string;
    };
    /** @description Representation of information from telemetry about the socket capacity by node
     *     role and OS of a cluster. */
    SocketTotalsNodeRoleOSMetricNode: {
      socket_totals?: components['schemas']['SocketTotalNodeRoleOSMetricNode'][];
    };
    /** @description Representation of a storage quota  */
    StorageQuota: {
      /** @description Unit of storage */
      unit?: string;
      /**
       * Format: float
       * @description Numerical value
       */
      value?: number;
    };
    /** @description Isolated STS support role created per organization. */
    StsSupportJumpRole: {
      /** @description ARN of the support role created in the SRE jump account. */
      role_arn?: string;
    };
    SubnetNetworkVerification: {
      /** @description Indicates the type of this object. Will be 'SubnetNetworkVerification' if this is a complete object or 'SubnetNetworkVerificationLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Slice of failures that happened during a subnet network verification. */
      details?: string[];
      /** @description Platform supplied to the network verifier for this subnet. */
      platform?: components['schemas']['Platform'];
      /** @description State of the subnet network verification. */
      state?: string;
      /** @description Tags supplied to the network verifier for this subnet. */
      tags?: {
        [key: string]: string;
      };
    };
    /** @description AWS subnetwork object to be used while installing a cluster */
    Subnetwork: {
      /** @description The CIDR Block of the subnet. */
      cidr_block?: string;
      /** @description The availability zone to which the subnet is related. */
      availability_zone?: string;
      /** @description Name of the subnet according to its `Name` tag on AWS. */
      name?: string;
      /** @description Whether or not it is a public subnet. */
      public?: boolean;
      /** @description If the resource is RH managed. */
      red_hat_managed?: boolean;
      /** @description The subnet ID to be used while installing a cluster. */
      subnet_id?: string;
    };
    /** @description Definition of a subscription. */
    Subscription: {
      /** @description Indicates the type of this object. Will be 'Subscription' if this is a complete object or 'SubscriptionLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
    };
    /** @description Representation of a syncset. */
    Syncset: {
      /** @description Indicates the type of this object. Will be 'Syncset' if this is a complete object or 'SyncsetLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description List of k8s objects to configure for the cluster. */
      resources?: Record<string, never>[];
    };
    /** @description Representation of a Taint set on a MachinePool in a cluster. */
    Taint: {
      /** @description The effect on the node for the pods matching the taint, i.e: NoSchedule, NoExecute, PreferNoSchedule. */
      effect?: string;
      /** @description The key for the taint */
      key?: string;
      /** @description The value for the taint. */
      value?: string;
    };
    /** @description The claim mappings defined for users and groups. */
    TokenClaimMappings: {
      /** @description Groups is a name of the claim that should be used to construct groups for the cluster identity. */
      groups?: components['schemas']['GroupsClaim'];
      /** @description Username is a name of the claim that should be used to construct usernames for the cluster identity. */
      username?: components['schemas']['UsernameClaim'];
    };
    /** @description The rule that is applied to validate token claims to authenticate users. */
    TokenClaimValidationRule: {
      /** @description Claim is a name of a required claim. */
      claim?: string;
      /** @description RequiredValue is the required value for the claim. */
      required_value?: string;
    };
    /** @description Representation of a token issuer used in an external authentication. */
    TokenIssuer: {
      /** @description Certificate bundle to use to validate server certificates for the configured URL. */
      ca?: string;
      /** @description URL is the serving URL of the token issuer.
       *     It must be a valid url and use the 'https' scheme.
       *     This is required. */
      url?: string;
      /** @description Audiences is an array of audiences that the token was issued for.
       *     Valid tokens must include at least one of these values in their
       *     "aud" claim.
       *     Must have at least one audience and a maximum of ten.
       *     Any clients defined for this external authentication must have their id included here. */
      audiences?: string[];
    };
    /** @description Representation of a trusted ip address in clusterdeployment. */
    TrustedIp: {
      /** @description Indicates the type of this object. Will be 'TrustedIp' if this is a complete object or 'TrustedIpLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description The boolean set to show if the ip is enabled. */
      enabled?: boolean;
    };
    /** @description Representation of a tuning config. */
    TuningConfig: {
      /** @description Indicates the type of this object. Will be 'TuningConfig' if this is a complete object or 'TuningConfigLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Name of the tuning config. */
      name?: string;
      /** @description Spec of the tuning config. */
      spec?: Record<string, never>;
    };
    /** @description Representation of an upgrade policy that can be set for a cluster. */
    UpgradePolicy: {
      /** @description Indicates the type of this object. Will be 'UpgradePolicy' if this is a complete object or 'UpgradePolicyLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Cluster ID this upgrade policy is defined for. */
      cluster_id?: string;
      /** @description Indicates if minor version upgrades are allowed for automatic upgrades (for manual it's always allowed). */
      enable_minor_version_upgrades?: boolean;
      /**
       * Format: date-time
       * @description Next time the upgrade should run.
       */
      next_run?: string;
      /** @description Schedule cron expression that defines automatic upgrade scheduling. */
      schedule?: string;
      /** @description Schedule type of the upgrade. */
      schedule_type?: components['schemas']['ScheduleType'];
      /** @description Upgrade type specify the type of the upgrade. */
      upgrade_type?: components['schemas']['UpgradeType'];
      /** @description Version is the desired upgrade version. */
      version?: string;
    };
    /** @description Representation of an upgrade policy state that that is set for a cluster. */
    UpgradePolicyState: {
      /** @description Indicates the type of this object. Will be 'UpgradePolicyState' if this is a complete object or 'UpgradePolicyStateLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description Description of the state. */
      description?: string;
      /** @description State value can be 'pending', 'scheduled', 'cancelled', 'started', 'delayed',
       *     'failed' or 'completed'. */
      value?: components['schemas']['UpgradePolicyStateValue'];
    };
    /**
     * @description Overall state of a cluster upgrade policy.
     * @enum {string}
     */
    UpgradePolicyStateValue: UpgradePolicyStateValue;
    /**
     * @description UpgradeType defines which type of upgrade should be used.
     * @enum {string}
     */
    UpgradeType: UpgradeType;
    /** @description Representation of a user. */
    User: {
      /** @description Indicates the type of this object. Will be 'User' if this is a complete object or 'UserLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
    };
    /** @description The username claim mapping. */
    UsernameClaim: {
      /** @description The claim used in the token. */
      claim?: string;
      /** @description A prefix contatenated in the claim (Optional). */
      prefix?: string;
      /** @description PrefixPolicy specifies how a prefix should apply.
       *
       *     By default, claims other than `email` will be prefixed with the issuer URL to
       *     prevent naming clashes with other plugins.
       *
       *     Set to "NoPrefix" to disable prefixing.
       *
       *     If a prefix is defined, this will be set to 'Prefix' by default. */
      prefix_policy?: string;
    };
    /** @description Numeric value and the unit used to measure it.
     *
     *     Units are not mandatory, and they're not specified for some resources. For
     *     resources that use bytes, the accepted units are:
     *
     *     - 1 B = 1 byte
     *     - 1 KB = 10^3 bytes
     *     - 1 MB = 10^6 bytes
     *     - 1 GB = 10^9 bytes
     *     - 1 TB = 10^12 bytes
     *     - 1 PB = 10^15 bytes
     *
     *     - 1 B = 1 byte
     *     - 1 KiB = 2^10 bytes
     *     - 1 MiB = 2^20 bytes
     *     - 1 GiB = 2^30 bytes
     *     - 1 TiB = 2^40 bytes
     *     - 1 PiB = 2^50 bytes */
    Value: {
      /** @description Name of the unit used to measure the value. */
      unit?: string;
      /**
       * Format: float
       * @description Numeric value.
       */
      value?: number;
    };
    /** @description Representation of an _OpenShift_ version. */
    Version: {
      /** @description Indicates the type of this object. Will be 'Version' if this is a complete object or 'VersionLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description GCPMarketplaceEnabled indicates if this version can be used to create GCP Marketplace clusters. */
      gcp_marketplace_enabled?: boolean;
      /** @description ROSAEnabled indicates whether this version can be used to create ROSA clusters. */
      rosa_enabled?: boolean;
      /** @description AvailableUpgrades is the list of versions this version can be upgraded to. */
      available_upgrades?: string[];
      /** @description ChannelGroup is the name of the group where this image belongs.
       *     ChannelGroup is a mechanism to partition the images to different groups,
       *     each image belongs to only a single group. */
      channel_group?: string;
      /** @description Indicates if this should be selected as the default version when a cluster is created
       *     without specifying explicitly the version. */
      default?: boolean;
      /** @description Indicates if this version can be used to create clusters. */
      enabled?: boolean;
      /**
       * Format: date-time
       * @description EndOfLifeTimestamp is the date and time when the version will get to End of Life, using the
       *     format defined in https://www.ietf.org/rfc/rfc3339.txt[RC3339].
       */
      end_of_life_timestamp?: string;
      /** @description HostedControlPlaneDefault is a flag that indicates if this should be selected as the default version when a
       *     HCP cluster is created without specifying explicitly the version. */
      hosted_control_plane_default?: boolean;
      /** @description HostedControlPlaneEnabled indicates whether this version can be used to create HCP clusters. */
      hosted_control_plane_enabled?: boolean;
      /** @description ImageOverrides contains the lists of images per cloud provider. */
      image_overrides?: components['schemas']['ImageOverrides'];
      /** @description RawID is the id of the version - without channel group and prefix. */
      raw_id?: string;
      /** @description ReleaseImage contains the URI of Openshift release image for amd64 architecture. */
      release_image?: string;
      /** @description ReleaseImages contains the URI of OpenShift release images for arm64 and multi architectures. */
      release_images?: components['schemas']['ReleaseImages'];
      /** @description WifEnabled is a flag that indicates whether this version is enabled for Workload Identity Federation. */
      wif_enabled?: boolean;
    };
    /** @description Representation of an _OpenShift_ version gate. */
    VersionGate: {
      /** @description Indicates the type of this object. Will be 'VersionGate' if this is a complete object or 'VersionGateLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description STSOnly indicates if this version gate is for STS clusters only,
       *     deprecated: to be replaced with ClusterCondition */
      sts_only?: boolean;
      /** @description ClusterCondition aims at selecting the clusters targeted by this version gate,
       *     ignored if STSOnly is true */
      cluster_condition?: string;
      /**
       * Format: date-time
       * @description CreationTimestamp is the date and time when the version gate was created,
       *     format defined in https://www.ietf.org/rfc/rfc3339.txt[RC3339].
       */
      creation_timestamp?: string;
      /** @description Description of the version gate. */
      description?: string;
      /** @description DocumentationURL is the URL for the documentation of the version gate. */
      documentation_url?: string;
      /** @description Label representing the version gate in OpenShift. */
      label?: string;
      /** @description Value represents the required value of the label. */
      value?: string;
      /** @description VersionRawIDPrefix represents the versions prefix that the gate applies to. */
      version_raw_id_prefix?: string;
      /** @description WarningMessage is a warning that will be displayed to the user before they acknowledge the gate */
      warning_message?: string;
    };
    /** @description VersionGateAgreement represents a version gate that the user agreed to for a specific cluster. */
    VersionGateAgreement: {
      /** @description Indicates the type of this object. Will be 'VersionGateAgreement' if this is a complete object or 'VersionGateAgreementLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /**
       * Format: date-time
       * @description The time the user agreed to the version gate
       */
      agreed_timestamp?: string;
      /** @description link to the version gate that the user agreed to */
      version_gate?: components['schemas']['VersionGate'];
    };
    /** @enum {string} */
    WifAccessMethod: WifAccessMethod;
    /** @description Definition of an wif_config resource. */
    WifConfig: {
      /** @description Indicates the type of this object. Will be 'WifConfig' if this is a complete object or 'WifConfigLink' if it is just a link. */
      kind?: string;
      /** @description Unique identifier of the object. */
      id?: string;
      /** @description Self link. */
      href?: string;
      /** @description The name OCM clients will display for this wif_config. */
      display_name?: string;
      /** @description Holds GCP related data. */
      gcp?: components['schemas']['WifGcp'];
      /** @description The OCM organization that this wif_config resource belongs to. */
      organization?: components['schemas']['OrganizationLink'];
      /** @description Wif template(s) used to configure IAM resources */
      wif_templates?: string[];
    };
    /** @description Configuration status of a WifConfig. */
    WifConfigStatus: {
      /** @description Indicates the current status of the WifConfig resource configuration.
       *     - `false`: The WifConfig resource has a user configuration error.
       *     - `true`: The resources associated with the WifConfig object are properly configured and operational at the time of the check. */
      configured?: boolean;
      /** @description Provides additional information about the WifConfig resource status.
       *     - When `Configured` is `false`, this field contains details about the user configuration error.
       *     - When `Configured` is `true`, this field may be empty or contain optional notes about the configuration. */
      description?: string;
    };
    WifCredentialRequest: {
      secret_ref?: components['schemas']['WifSecretRef'];
      service_account_names?: string[];
    };
    WifGcp: {
      /** @description This represents the GCP project ID in which, when specified,
       *     the wif workload WorkloadIdentityPool resources will be configured. */
      federated_project_id?: string;
      /** @description This represents the GCP project number in which, when specified,
       *     the wif workload WorkloadIdentityPool resources will be configured. */
      federated_project_number?: string;
      /** @description This is the service account email that OCM will use to access other SAs.  */
      impersonator_email?: string;
      /** @description This represents the GCP project ID in which the wif resources will be configured. */
      project_id?: string;
      /** @description This represents the GCP project number in which the wif resources will be configured. */
      project_number?: string;
      /** @description Prefix for naming GCP custom roles configured. */
      role_prefix?: string;
      /** @description The list of service accounts and their associated roles that will need to be
       *     configured on the user's GCP project. */
      service_accounts?: components['schemas']['WifServiceAccount'][];
      /** @description Defines the access configuration for support. */
      support?: components['schemas']['WifSupport'];
      /** @description The workload identity configuration data that will be used to create the
       *     workload identity pool on the user's account. */
      workload_identity_pool?: components['schemas']['WifPool'];
    };
    WifIdentityProvider: {
      allowed_audiences?: string[];
      identity_provider_id?: string;
      issuer_url?: string;
      jwks?: string;
    };
    WifPool: {
      /** @description Identity provider configuration data that will be created as part of the
       *     workload identity pool. */
      identity_provider?: components['schemas']['WifIdentityProvider'];
      /** @description The Id of the workload identity pool. */
      pool_id?: string;
      /** @description The display name of the workload identity pool. */
      pool_name?: string;
    };
    WifResourceBinding: {
      name?: string;
      type?: string;
    };
    WifRole: {
      permissions?: string[];
      predefined?: boolean;
      resource_bindings?: components['schemas']['WifResourceBinding'][];
      role_id?: string;
    };
    WifSecretRef: {
      name?: string;
      namespace?: string;
    };
    WifServiceAccount: {
      access_method?: components['schemas']['WifAccessMethod'];
      credential_request?: components['schemas']['WifCredentialRequest'];
      osd_role?: string;
      roles?: components['schemas']['WifRole'][];
      service_account_id?: string;
    };
    WifSupport: {
      principal?: string;
      roles?: components['schemas']['WifRole'][];
    };
    /**
     * @description Type of wildcard policy.
     * @enum {string}
     */
    WildcardPolicy: WildcardPolicy;
    Error: {
      /** @description Indicates the type of this object. Will always be 'Error' */
      kind?: string;
      /**
       * Format: int32
       * @description Numeric identifier of the error.
       */
      id?: number;
      /** @description Self link. */
      href?: string;
      /** @description Globally unique code of the error, composed of the unique identifier of the API and the numeric identifier of the error. For example, for if the numeric identifier of the error is `93` and the identifier of the API is `clusters_mgmt` then the code will be `CLUSTERS-MGMT-93`. */
      code?: string;
      /** @description Human readable description of the error. */
      reason?: string;
      /** @description Extra information about the error. */
      details?: {
        [key: string]: unknown;
      };
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type SchemaMetadata = components['schemas']['Metadata'];
export type SchemaAmiOverride = components['schemas']['AMIOverride'];
export type SchemaAws = components['schemas']['AWS'];
export type SchemaAwsBackupConfig = components['schemas']['AWSBackupConfig'];
export type SchemaAwsCapacityReservation = components['schemas']['AWSCapacityReservation'];
export type SchemaAwsFlavour = components['schemas']['AWSFlavour'];
export type SchemaAwsInfrastructureAccessRole =
  components['schemas']['AWSInfrastructureAccessRole'];
export type SchemaAwsInfrastructureAccessRoleGrant =
  components['schemas']['AWSInfrastructureAccessRoleGrant'];
export type SchemaAwsInfrastructureAccessRoleGrantState =
  components['schemas']['AWSInfrastructureAccessRoleGrantState'];
export type SchemaAwsInfrastructureAccessRoleState =
  components['schemas']['AWSInfrastructureAccessRoleState'];
export type SchemaAwsMachinePool = components['schemas']['AWSMachinePool'];
export type SchemaAwsNodePool = components['schemas']['AWSNodePool'];
export type SchemaAwsShard = components['schemas']['AWSShard'];
export type SchemaAwsSpotMarketOptions = components['schemas']['AWSSpotMarketOptions'];
export type SchemaAwsVolume = components['schemas']['AWSVolume'];
export type SchemaAwsstsAccountRole = components['schemas']['AWSSTSAccountRole'];
export type SchemaAwsstsPolicy = components['schemas']['AWSSTSPolicy'];
export type SchemaAwsstsRole = components['schemas']['AWSSTSRole'];
export type SchemaCcs = components['schemas']['CCS'];
export type SchemaCidrBlockAccess = components['schemas']['CIDRBlockAccess'];
export type SchemaCidrBlockAllowAccess = components['schemas']['CIDRBlockAllowAccess'];
export type SchemaCpuTotalNodeRoleOsMetricNode =
  components['schemas']['CPUTotalNodeRoleOSMetricNode'];
export type SchemaCpuTotalsNodeRoleOsMetricNode =
  components['schemas']['CPUTotalsNodeRoleOSMetricNode'];
export type SchemaDns = components['schemas']['DNS'];
export type SchemaDnsDomain = components['schemas']['DNSDomain'];
export type SchemaGcp = components['schemas']['GCP'];
export type SchemaGcpEncryptionKey = components['schemas']['GCPEncryptionKey'];
export type SchemaGcpFlavour = components['schemas']['GCPFlavour'];
export type SchemaGcpImageOverride = components['schemas']['GCPImageOverride'];
export type SchemaGcpMachinePool = components['schemas']['GCPMachinePool'];
export type SchemaGcpNetwork = components['schemas']['GCPNetwork'];
export type SchemaGcpVolume = components['schemas']['GCPVolume'];
export type SchemaHtPasswdIdentityProvider = components['schemas']['HTPasswdIdentityProvider'];
export type SchemaHtPasswdUser = components['schemas']['HTPasswdUser'];
export type SchemaLdapAttributes = components['schemas']['LDAPAttributes'];
export type SchemaLdapIdentityProvider = components['schemas']['LDAPIdentityProvider'];
export type SchemaSts = components['schemas']['STS'];
export type SchemaStsCredentialRequest = components['schemas']['STSCredentialRequest'];
export type SchemaStsOperator = components['schemas']['STSOperator'];
export type SchemaAddOn = components['schemas']['AddOn'];
export type SchemaAddOnConfig = components['schemas']['AddOnConfig'];
export type SchemaAddOnEnvironmentVariable = components['schemas']['AddOnEnvironmentVariable'];
export type SchemaAddOnInstallMode = components['schemas']['AddOnInstallMode'];
export type SchemaAddOnInstallation = components['schemas']['AddOnInstallation'];
export type SchemaAddOnInstallationBilling = components['schemas']['AddOnInstallationBilling'];
export type SchemaAddOnInstallationParameter = components['schemas']['AddOnInstallationParameter'];
export type SchemaAddOnInstallationState = components['schemas']['AddOnInstallationState'];
export type SchemaAddOnNamespace = components['schemas']['AddOnNamespace'];
export type SchemaAddOnParameter = components['schemas']['AddOnParameter'];
export type SchemaAddOnParameterOption = components['schemas']['AddOnParameterOption'];
export type SchemaAddOnRequirement = components['schemas']['AddOnRequirement'];
export type SchemaAddOnRequirementStatus = components['schemas']['AddOnRequirementStatus'];
export type SchemaAddOnSecretPropagation = components['schemas']['AddOnSecretPropagation'];
export type SchemaAddOnSubOperator = components['schemas']['AddOnSubOperator'];
export type SchemaAddOnVersion = components['schemas']['AddOnVersion'];
export type SchemaAdditionalCatalogSource = components['schemas']['AdditionalCatalogSource'];
export type SchemaAddonUpgradePolicy = components['schemas']['AddonUpgradePolicy'];
export type SchemaAddonUpgradePolicyState = components['schemas']['AddonUpgradePolicyState'];
export type SchemaAdminCredentials = components['schemas']['AdminCredentials'];
export type SchemaAlertInfo = components['schemas']['AlertInfo'];
export type SchemaAlertSeverity = components['schemas']['AlertSeverity'];
export type SchemaAlertsInfo = components['schemas']['AlertsInfo'];
export type SchemaAuditLog = components['schemas']['AuditLog'];
export type SchemaAutoscalerResourceLimits = components['schemas']['AutoscalerResourceLimits'];
export type SchemaAutoscalerResourceLimitsGpuLimit =
  components['schemas']['AutoscalerResourceLimitsGPULimit'];
export type SchemaAutoscalerScaleDownConfig = components['schemas']['AutoscalerScaleDownConfig'];
export type SchemaAwsAutoNode = components['schemas']['AwsAutoNode'];
export type SchemaAwsEtcdEncryption = components['schemas']['AwsEtcdEncryption'];
export type SchemaAzure = components['schemas']['Azure'];
export type SchemaAzureControlPlaneManagedIdentity =
  components['schemas']['AzureControlPlaneManagedIdentity'];
export type SchemaAzureDataPlaneManagedIdentity =
  components['schemas']['AzureDataPlaneManagedIdentity'];
export type SchemaAzureEtcdDataEncryption = components['schemas']['AzureEtcdDataEncryption'];
export type SchemaAzureEtcdDataEncryptionCustomerManaged =
  components['schemas']['AzureEtcdDataEncryptionCustomerManaged'];
export type SchemaAzureEtcdEncryption = components['schemas']['AzureEtcdEncryption'];
export type SchemaAzureKmsEncryption = components['schemas']['AzureKmsEncryption'];
export type SchemaAzureKmsKey = components['schemas']['AzureKmsKey'];
export type SchemaAzureNodePool = components['schemas']['AzureNodePool'];
export type SchemaAzureNodePoolEncryptionAtHost =
  components['schemas']['AzureNodePoolEncryptionAtHost'];
export type SchemaAzureNodePoolOsDisk = components['schemas']['AzureNodePoolOsDisk'];
export type SchemaAzureNodesOutboundConnectivity =
  components['schemas']['AzureNodesOutboundConnectivity'];
export type SchemaAzureOperatorsAuthentication =
  components['schemas']['AzureOperatorsAuthentication'];
export type SchemaAzureOperatorsAuthenticationManagedIdentities =
  components['schemas']['AzureOperatorsAuthenticationManagedIdentities'];
export type SchemaAzureServiceManagedIdentity =
  components['schemas']['AzureServiceManagedIdentity'];
export type SchemaBackup = components['schemas']['Backup'];
export type SchemaBillingModel = components['schemas']['BillingModel'];
export type SchemaBillingModelItem = components['schemas']['BillingModelItem'];
export type SchemaBreakGlassCredential = components['schemas']['BreakGlassCredential'];
export type SchemaBreakGlassCredentialStatus = components['schemas']['BreakGlassCredentialStatus'];
export type SchemaByoOidc = components['schemas']['ByoOidc'];
export type SchemaClientComponent = components['schemas']['ClientComponent'];
export type SchemaCloudVpc = components['schemas']['CloudVPC'];
export type SchemaCloudProvider = components['schemas']['CloudProvider'];
export type SchemaCloudProviderData = components['schemas']['CloudProviderData'];
export type SchemaCloudRegion = components['schemas']['CloudRegion'];
export type SchemaCluster = components['schemas']['Cluster'];
export type SchemaClusterApi = components['schemas']['ClusterAPI'];
export type SchemaClusterArchitecture = components['schemas']['ClusterArchitecture'];
export type SchemaClusterAutoNode = components['schemas']['ClusterAutoNode'];
export type SchemaClusterAutoNodeStatus = components['schemas']['ClusterAutoNodeStatus'];
export type SchemaClusterAutoscaler = components['schemas']['ClusterAutoscaler'];
export type SchemaClusterConfigurationMode = components['schemas']['ClusterConfigurationMode'];
export type SchemaClusterConsole = components['schemas']['ClusterConsole'];
export type SchemaClusterCredentials = components['schemas']['ClusterCredentials'];
export type SchemaClusterDeployment = components['schemas']['ClusterDeployment'];
export type SchemaClusterHealthState = components['schemas']['ClusterHealthState'];
export type SchemaClusterImageRegistry = components['schemas']['ClusterImageRegistry'];
export type SchemaClusterLink = components['schemas']['ClusterLink'];
export type SchemaClusterMigration = components['schemas']['ClusterMigration'];
export type SchemaClusterMigrationState = components['schemas']['ClusterMigrationState'];
export type SchemaClusterMigrationStateValue = components['schemas']['ClusterMigrationStateValue'];
export type SchemaClusterMigrationType = components['schemas']['ClusterMigrationType'];
export type SchemaClusterNodes = components['schemas']['ClusterNodes'];
export type SchemaClusterOperatorInfo = components['schemas']['ClusterOperatorInfo'];
export type SchemaClusterOperatorState = components['schemas']['ClusterOperatorState'];
export type SchemaClusterOperatorsInfo = components['schemas']['ClusterOperatorsInfo'];
export type SchemaClusterRegistration = components['schemas']['ClusterRegistration'];
export type SchemaClusterRegistryConfig = components['schemas']['ClusterRegistryConfig'];
export type SchemaClusterResources = components['schemas']['ClusterResources'];
export type SchemaClusterState = components['schemas']['ClusterState'];
export type SchemaClusterStatus = components['schemas']['ClusterStatus'];
export type SchemaComponentRoute = components['schemas']['ComponentRoute'];
export type SchemaComponentRouteType = components['schemas']['ComponentRouteType'];
export type SchemaControlPlane = components['schemas']['ControlPlane'];
export type SchemaControlPlaneUpgradePolicy = components['schemas']['ControlPlaneUpgradePolicy'];
export type SchemaCredentialRequest = components['schemas']['CredentialRequest'];
export type SchemaDeleteProtection = components['schemas']['DeleteProtection'];
export type SchemaDetectionType = components['schemas']['DetectionType'];
export type SchemaEc2MetadataHttpTokens = components['schemas']['Ec2MetadataHttpTokens'];
export type SchemaEncryptionKey = components['schemas']['EncryptionKey'];
export type SchemaEnvironment = components['schemas']['Environment'];
export type SchemaEvent = components['schemas']['Event'];
export type SchemaExternalAuth = components['schemas']['ExternalAuth'];
export type SchemaExternalAuthClaim = components['schemas']['ExternalAuthClaim'];
export type SchemaExternalAuthClientConfig = components['schemas']['ExternalAuthClientConfig'];
export type SchemaExternalAuthClientType = components['schemas']['ExternalAuthClientType'];
export type SchemaExternalAuthConfig = components['schemas']['ExternalAuthConfig'];
export type SchemaExternalAuthConfigState = components['schemas']['ExternalAuthConfigState'];
export type SchemaExternalAuthState = components['schemas']['ExternalAuthState'];
export type SchemaExternalAuthStatus = components['schemas']['ExternalAuthStatus'];
export type SchemaExternalConfiguration = components['schemas']['ExternalConfiguration'];
export type SchemaFlavour = components['schemas']['Flavour'];
export type SchemaFlavourNodes = components['schemas']['FlavourNodes'];
export type SchemaGcpAuthentication = components['schemas']['GcpAuthentication'];
export type SchemaGcpPrivateServiceConnect = components['schemas']['GcpPrivateServiceConnect'];
export type SchemaGcpSecurity = components['schemas']['GcpSecurity'];
export type SchemaGithubIdentityProvider = components['schemas']['GithubIdentityProvider'];
export type SchemaGitlabIdentityProvider = components['schemas']['GitlabIdentityProvider'];
export type SchemaGoogleIdentityProvider = components['schemas']['GoogleIdentityProvider'];
export type SchemaGroup = components['schemas']['Group'];
export type SchemaGroupsClaim = components['schemas']['GroupsClaim'];
export type SchemaHypershift = components['schemas']['Hypershift'];
export type SchemaHypershiftConfig = components['schemas']['HypershiftConfig'];
export type SchemaIdentityProvider = components['schemas']['IdentityProvider'];
export type SchemaIdentityProviderMappingMethod =
  components['schemas']['IdentityProviderMappingMethod'];
export type SchemaIdentityProviderType = components['schemas']['IdentityProviderType'];
export type SchemaImageMirror = components['schemas']['ImageMirror'];
export type SchemaImageOverrides = components['schemas']['ImageOverrides'];
export type SchemaInflightCheck = components['schemas']['InflightCheck'];
export type SchemaInflightCheckState = components['schemas']['InflightCheckState'];
export type SchemaIngress = components['schemas']['Ingress'];
export type SchemaInstanceIamRoles = components['schemas']['InstanceIAMRoles'];
export type SchemaKeyRing = components['schemas']['KeyRing'];
export type SchemaKubeletConfig = components['schemas']['KubeletConfig'];
export type SchemaLabel = components['schemas']['Label'];
export type SchemaLimitedSupportReason = components['schemas']['LimitedSupportReason'];
export type SchemaLimitedSupportReasonOverride =
  components['schemas']['LimitedSupportReasonOverride'];
export type SchemaLimitedSupportReasonTemplate =
  components['schemas']['LimitedSupportReasonTemplate'];
export type SchemaListeningMethod = components['schemas']['ListeningMethod'];
export type SchemaLoadBalancerFlavor = components['schemas']['LoadBalancerFlavor'];
export type SchemaLog = components['schemas']['Log'];
export type SchemaMachinePool = components['schemas']['MachinePool'];
export type SchemaMachinePoolAutoscaling = components['schemas']['MachinePoolAutoscaling'];
export type SchemaMachinePoolSecurityGroupFilter =
  components['schemas']['MachinePoolSecurityGroupFilter'];
export type SchemaMachineType = components['schemas']['MachineType'];
export type SchemaMachineTypeCategory = components['schemas']['MachineTypeCategory'];
export type SchemaMachineTypeSize = components['schemas']['MachineTypeSize'];
export type SchemaManagedService = components['schemas']['ManagedService'];
export type SchemaManifest = components['schemas']['Manifest'];
export type SchemaMarketType = components['schemas']['MarketType'];
export type SchemaNamespaceOwnershipPolicy = components['schemas']['NamespaceOwnershipPolicy'];
export type SchemaNetwork = components['schemas']['Network'];
export type SchemaNetworkVerification = components['schemas']['NetworkVerification'];
export type SchemaNodeInfo = components['schemas']['NodeInfo'];
export type SchemaNodePool = components['schemas']['NodePool'];
export type SchemaNodePoolAutoscaling = components['schemas']['NodePoolAutoscaling'];
export type SchemaNodePoolManagementUpgrade = components['schemas']['NodePoolManagementUpgrade'];
export type SchemaNodePoolState = components['schemas']['NodePoolState'];
export type SchemaNodePoolStatus = components['schemas']['NodePoolStatus'];
export type SchemaNodePoolUpgradePolicy = components['schemas']['NodePoolUpgradePolicy'];
export type SchemaNodeType = components['schemas']['NodeType'];
export type SchemaNodesInfo = components['schemas']['NodesInfo'];
export type SchemaOidcConfig = components['schemas']['OidcConfig'];
export type SchemaOidcThumbprint = components['schemas']['OidcThumbprint'];
export type SchemaOidcThumbprintInput = components['schemas']['OidcThumbprintInput'];
export type SchemaOpenIdClaims = components['schemas']['OpenIDClaims'];
export type SchemaOpenIdIdentityProvider = components['schemas']['OpenIDIdentityProvider'];
export type SchemaOperatorIamRole = components['schemas']['OperatorIAMRole'];
export type SchemaOrganizationLink = components['schemas']['OrganizationLink'];
export type SchemaPendingDeleteCluster = components['schemas']['PendingDeleteCluster'];
export type SchemaPlatform = components['schemas']['Platform'];
export type SchemaPrivateLinkClusterConfiguration =
  components['schemas']['PrivateLinkClusterConfiguration'];
export type SchemaPrivateLinkConfiguration = components['schemas']['PrivateLinkConfiguration'];
export type SchemaPrivateLinkPrincipal = components['schemas']['PrivateLinkPrincipal'];
export type SchemaPrivateLinkPrincipals = components['schemas']['PrivateLinkPrincipals'];
export type SchemaProcessorType = components['schemas']['ProcessorType'];
export type SchemaProduct = components['schemas']['Product'];
export type SchemaProductMinimalVersion = components['schemas']['ProductMinimalVersion'];
export type SchemaProductTechnologyPreview = components['schemas']['ProductTechnologyPreview'];
export type SchemaProvisionShard = components['schemas']['ProvisionShard'];
export type SchemaProvisionShardTopology = components['schemas']['ProvisionShardTopology'];
export type SchemaProxy = components['schemas']['Proxy'];
export type SchemaRegistryAllowlist = components['schemas']['RegistryAllowlist'];
export type SchemaRegistryLocation = components['schemas']['RegistryLocation'];
export type SchemaRegistrySources = components['schemas']['RegistrySources'];
export type SchemaReleaseImageDetails = components['schemas']['ReleaseImageDetails'];
export type SchemaReleaseImages = components['schemas']['ReleaseImages'];
export type SchemaResourceRange = components['schemas']['ResourceRange'];
export type SchemaRolePolicy = components['schemas']['RolePolicy'];
export type SchemaRolePolicyBinding = components['schemas']['RolePolicyBinding'];
export type SchemaRolePolicyBindingStatus = components['schemas']['RolePolicyBindingStatus'];
export type SchemaRootVolume = components['schemas']['RootVolume'];
export type SchemaScheduleType = components['schemas']['ScheduleType'];
export type SchemaSdnToOvnClusterMigration = components['schemas']['SdnToOvnClusterMigration'];
export type SchemaSecurityGroup = components['schemas']['SecurityGroup'];
export type SchemaServerConfig = components['schemas']['ServerConfig'];
export type SchemaSocketTotalNodeRoleOsMetricNode =
  components['schemas']['SocketTotalNodeRoleOSMetricNode'];
export type SchemaSocketTotalsNodeRoleOsMetricNode =
  components['schemas']['SocketTotalsNodeRoleOSMetricNode'];
export type SchemaStorageQuota = components['schemas']['StorageQuota'];
export type SchemaStsSupportJumpRole = components['schemas']['StsSupportJumpRole'];
export type SchemaSubnetNetworkVerification = components['schemas']['SubnetNetworkVerification'];
export type SchemaSubnetwork = components['schemas']['Subnetwork'];
export type SchemaSubscription = components['schemas']['Subscription'];
export type SchemaSyncset = components['schemas']['Syncset'];
export type SchemaTaint = components['schemas']['Taint'];
export type SchemaTokenClaimMappings = components['schemas']['TokenClaimMappings'];
export type SchemaTokenClaimValidationRule = components['schemas']['TokenClaimValidationRule'];
export type SchemaTokenIssuer = components['schemas']['TokenIssuer'];
export type SchemaTrustedIp = components['schemas']['TrustedIp'];
export type SchemaTuningConfig = components['schemas']['TuningConfig'];
export type SchemaUpgradePolicy = components['schemas']['UpgradePolicy'];
export type SchemaUpgradePolicyState = components['schemas']['UpgradePolicyState'];
export type SchemaUpgradePolicyStateValue = components['schemas']['UpgradePolicyStateValue'];
export type SchemaUpgradeType = components['schemas']['UpgradeType'];
export type SchemaUser = components['schemas']['User'];
export type SchemaUsernameClaim = components['schemas']['UsernameClaim'];
export type SchemaValue = components['schemas']['Value'];
export type SchemaVersion = components['schemas']['Version'];
export type SchemaVersionGate = components['schemas']['VersionGate'];
export type SchemaVersionGateAgreement = components['schemas']['VersionGateAgreement'];
export type SchemaWifAccessMethod = components['schemas']['WifAccessMethod'];
export type SchemaWifConfig = components['schemas']['WifConfig'];
export type SchemaWifConfigStatus = components['schemas']['WifConfigStatus'];
export type SchemaWifCredentialRequest = components['schemas']['WifCredentialRequest'];
export type SchemaWifGcp = components['schemas']['WifGcp'];
export type SchemaWifIdentityProvider = components['schemas']['WifIdentityProvider'];
export type SchemaWifPool = components['schemas']['WifPool'];
export type SchemaWifResourceBinding = components['schemas']['WifResourceBinding'];
export type SchemaWifRole = components['schemas']['WifRole'];
export type SchemaWifSecretRef = components['schemas']['WifSecretRef'];
export type SchemaWifServiceAccount = components['schemas']['WifServiceAccount'];
export type SchemaWifSupport = components['schemas']['WifSupport'];
export type SchemaWildcardPolicy = components['schemas']['WildcardPolicy'];
export type SchemaError = components['schemas']['Error'];
export type $defs = Record<string, never>;
export enum AWSInfrastructureAccessRoleGrantState {
  deleting = 'deleting',
  failed = 'failed',
  pending = 'pending',
  ready = 'ready',
  removed = 'removed',
}
export enum AWSInfrastructureAccessRoleState {
  invalid = 'invalid',
  removed = 'removed',
  valid = 'valid',
}
export enum AddOnInstallMode {
  all_namespaces = 'all_namespaces',
  own_namespace = 'own_namespace',
}
export enum AddOnInstallationState {
  deleting = 'deleting',
  failed = 'failed',
  installing = 'installing',
  pending = 'pending',
  ready = 'ready',
}
export enum AlertSeverity {
  critical = 'critical',
  none = 'none',
  warning = 'warning',
}
export enum BillingModel {
  marketplace = 'marketplace',
  marketplace_aws = 'marketplace-aws',
  marketplace_gcp = 'marketplace-gcp',
  marketplace_rhm = 'marketplace-rhm',
  marketplace_azure = 'marketplace-azure',
  standard = 'standard',
}
export enum BreakGlassCredentialStatus {
  awaiting_revocation = 'awaiting_revocation',
  created = 'created',
  expired = 'expired',
  failed = 'failed',
  issued = 'issued',
  revoked = 'revoked',
}
export enum ClusterArchitecture {
  classic = 'classic',
  hcp = 'hcp',
}
export enum ClusterConfigurationMode {
  full = 'full',
  read_only = 'read_only',
}
export enum ClusterHealthState {
  healthy = 'healthy',
  unhealthy = 'unhealthy',
  unknown = 'unknown',
}
export enum ClusterMigrationStateValue {
  completed = 'completed',
  in_progress = 'in progress',
  scheduled = 'scheduled',
}
export enum ClusterMigrationType {
  sdnToOvn = 'sdnToOvn',
}
export enum ClusterOperatorState {
  available = 'available',
  degraded = 'degraded',
  failing = 'failing',
  upgrading = 'upgrading',
}
export enum ClusterState {
  error = 'error',
  hibernating = 'hibernating',
  installing = 'installing',
  pending = 'pending',
  powering_down = 'powering_down',
  ready = 'ready',
  resuming = 'resuming',
  uninstalling = 'uninstalling',
  unknown = 'unknown',
  updating = 'updating',
  validating = 'validating',
  waiting = 'waiting',
}
export enum ComponentRouteType {
  console = 'console',
  downloads = 'downloads',
  oauth = 'oauth',
}
export enum DetectionType {
  auto = 'auto',
  manual = 'manual',
}
export enum Ec2MetadataHttpTokens {
  optional = 'optional',
  required = 'required',
}
export enum ExternalAuthClientType {
  confidential = 'confidential',
  public = 'public',
}
export enum ExternalAuthConfigState {
  disabled = 'disabled',
  enabled = 'enabled',
}
export enum IdentityProviderMappingMethod {
  add = 'add',
  claim = 'claim',
  generate = 'generate',
  lookup = 'lookup',
}
export enum IdentityProviderType {
  LDAPIdentityProvider = 'LDAPIdentityProvider',
  GithubIdentityProvider = 'GithubIdentityProvider',
  GitlabIdentityProvider = 'GitlabIdentityProvider',
  GoogleIdentityProvider = 'GoogleIdentityProvider',
  HTPasswdIdentityProvider = 'HTPasswdIdentityProvider',
  OpenIDIdentityProvider = 'OpenIDIdentityProvider',
}
export enum InflightCheckState {
  failed = 'failed',
  passed = 'passed',
  pending = 'pending',
  running = 'running',
}
export enum ListeningMethod {
  external = 'external',
  internal = 'internal',
}
export enum LoadBalancerFlavor {
  classic = 'classic',
  nlb = 'nlb',
}
export enum MachineTypeCategory {
  accelerated_computing = 'accelerated_computing',
  compute_optimized = 'compute_optimized',
  general_purpose = 'general_purpose',
  memory_optimized = 'memory_optimized',
}
export enum MachineTypeSize {
  large = 'large',
  medium = 'medium',
  small = 'small',
}
export enum MarketType {
  CapacityBlocks = 'CapacityBlocks',
  OnDemand = 'OnDemand',
}
export enum NamespaceOwnershipPolicy {
  InterNamespaceAllowed = 'InterNamespaceAllowed',
  Strict = 'Strict',
}
export enum NodeType {
  compute = 'compute',
  infra = 'infra',
  master = 'master',
}
export enum Platform {
  aws = 'aws',
  aws_classic = 'aws-classic',
  aws_hosted_cp = 'aws-hosted-cp',
  gcp = 'gcp',
  hostedcluster = 'hostedcluster',
}
export enum ProcessorType {
  amd64 = 'amd64',
  arm64 = 'arm64',
}
export enum ProvisionShardTopology {
  dedicated = 'dedicated',
}
export enum ScheduleType {
  automatic = 'automatic',
  manual = 'manual',
}
export enum UpgradePolicyStateValue {
  cancelled = 'cancelled',
  completed = 'completed',
  delayed = 'delayed',
  failed = 'failed',
  pending = 'pending',
  scheduled = 'scheduled',
  started = 'started',
}
export enum UpgradeType {
  OSD = 'OSD',
  ADDON = 'ADDON',
  ControlPlane = 'ControlPlane',
  ControlPlaneCVE = 'ControlPlaneCVE',
  NodePool = 'NodePool',
}
export enum WifAccessMethod {
  impersonate = 'impersonate',
  vm = 'vm',
  wif = 'wif',
}
export enum WildcardPolicy {
  WildcardsAllowed = 'WildcardsAllowed',
  WildcardsDisallowed = 'WildcardsDisallowed',
}
export type operations = Record<string, never>;
